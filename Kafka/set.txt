BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="3" [2]="11" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.3.11(1)-release'
CASSANDRA_HOME=/opt/cassandra/apache-cassandra-3.11.1
CLASSPATH=/opt/jmeter/apache-jmeter-3.3/lib/ext/ApacheJMeter_core.jar:/opt/jmeter/apache-jmeter-3.3/lib/jorphan.jar:/opt/jmeter/apache-jmeter-3.3/lib/logkit-2.0.jar:.:/opt/java/jdk1.8.0_121/lib:/opt/java/jdk1.8.0_121/jre/lib:
COLORTERM=gnome-terminal
COLUMNS=269
DIRSTACK=()
DISPLAY=:0
DOCKER_HOST=tcp://localhost:2375
EUID=0
GRADLE_HOME=/usr/lib/gradle/4.6
GROUPS=()
HISTCONTROL=ignoredups:ignorespace
HISTFILE=/root/.bash_history
HISTFILESIZE=2000
HISTSIZE=1000
HOME=/root
HOSTNAME=Spontaneously
HOSTTYPE=x86_64
IFS=$' \t\n'
JAVA_HOME=/opt/java/jdk1.8.0_121
JMETER=/opt/jmeter/apache-jmeter-3.3
JRE_HOME=/opt/java/jdk1.8.0_121/jre
LANG=zh_CN.UTF-8
LANGUAGE=zh_CN:en_US:en
LC_ADDRESS=zh_CN.UTF-8
LC_CTYPE=zh_CN.UTF-8
LC_IDENTIFICATION=zh_CN.UTF-8
LC_MEASUREMENT=zh_CN.UTF-8
LC_MONETARY=zh_CN.UTF-8
LC_NAME=zh_CN.UTF-8
LC_NUMERIC=zh_CN.UTF-8
LC_PAPER=zh_CN.UTF-8
LC_TELEPHONE=zh_CN.UTF-8
LC_TIME=zh_CN.UTF-8
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=75
LOGNAME=root
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:'
M2_HOME=/opt/maven/apache-maven-3.5.0
MACHTYPE=x86_64-pc-linux-gnu
MAIL=/var/mail/root
MAILCHECK=60
OLDPWD=/opt/gradle
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/opt/java/jdk1.8.0_121/bin:/opt/java/jdk1.8.0_121/jre/bin:/usr/lib/gradle/4.6/bin:/opt/java/jdk1.8.0_121:/opt/anaconda3/bin:/opt/python/Python-3.6.4/bin:/opt/pycharm/pycharm-2017.3.2/bin:/opt/cassandra/apache-cassandra-3.11.1/bin:/opt/cassandra/apache-cassandra-3.11.1:/opt/redis/redis-3.2.8/src:/opt/maven/apache-maven-3.5.0/bin:/opt/java/jdk1.8.0_121/bin:/opt/java/jdk1.8.0_121/jre/bin:/opt/java/jdk1.8.0_121:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/opt/java/jdk1.8.0_121/bin:/opt/nodejs/webstorm/WebStorm-171.4424.63/bin:/root/.fabric8/bin
PIPESTATUS=([0]="0")
PPID=30847
PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
PS2='> '
PS4='+ '
PWD=/root
PYCHARM_HOME=/opt/pycharm/pycharm-2017.3.2
PYTHON_HOME=/opt/python/Python-3.6.4
QT_QPA_PLATFORMTHEME=appmenu-qt5
REDIS_HOME=/opt/redis/redis-3.2.8/src
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SUDO_COMMAND=/bin/su
SUDO_GID=1000
SUDO_UID=1000
SUDO_USER=hongfei
TERM=xterm
UID=0
USER=root
USERNAME=root
XAUTHORITY=/home/hongfei/.Xauthority
XDG_SEAT=seat0
XDG_SESSION_ID=c1
XDG_VTNR=7
_=clear
__git_printf_supports_v=yes
__grub_script_check_program=grub-script-check
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [bibtex]="!*.aux" [rgview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm)" [chromium-browser]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [makeinfo]="!*.texi*" [kwrite]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [lrunzip]="!*.lrz" [bzcat]="!*.?(t)bz?(2)" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [rpm2cpio]="!*.[rs]pm" [view]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [ly2dvi]="!*.ly" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [lzgrep]="!*.@(tlz|lzma)" [pyflakes]="!*.py" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [lzmore]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [poedit]="!*.po" [firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [madplay]="!*.mp3" [lbzcat]="!*.?(t)bz?(2)" [lilypond]="!*.ly" [gtranslator]="!*.po" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [sxemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [epdfview]="!*.pdf" [gpdf]="!*.[pf]df" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [pbzcat]="!*.?(t)bz?(2)" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [lzcat]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [vim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf14]="!*.@(?(e)ps|pdf)" [dvips]="!*.dvi" [lzfgrep]="!*.@(tlz|lzma)" [hbrun]="!*.[Hh][Rr][Bb]" [kbabel]="!*.po" [rview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [xv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [rgvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvitype]="!*.dvi" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [playmidi]="!*.@(mid?(i)|cmf)" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [xpdf]="!*.@(pdf|fdf)?(.@(gz|xz|Z|bz2))" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [lzegrep]="!*.@(tlz|lzma)" [aviplay]="!*.@(avi|asf|wmv)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [bunzip2]="!*.?(t)bz?(2)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [znew]="*.Z" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lokalize]="!*.po" [kate]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [unlzma]="!*.@(tlz|lzma)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vi]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [mozilla-firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [uncompress]="!*.Z" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [unpigz]="!*.@(Z|[gGd]z|t[ag]z)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [emacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ps2pdf]="!*.@(?(e)ps|pdf)" [kpdf]="!*.@(?(e)ps|pdf)" [oomath]="!*.@(sxm|smf|mml|odf)" [compress]="*.Z" [iceweasel]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [mpg321]="!*.mp3" [mpg123]="!*.mp3" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [unzip]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [pbunzip2]="!*.?(t)bz?(2)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [dvipdf]="!*.dvi" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdfm]="!*.dvi" [oobase]="!*.odb" [texi2html]="!*.texi*" [zipinfo]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [google-chrome]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2)))" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [bzme]="!*.@(zip|z|gz|tgz)" [xfig]="!*.fig" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [dviselect]="!*.dvi" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" )
__all_modules () 
{ 
    while read name; do
        name=${name%% *};
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-modules 2> /dev/null)
}
__cards () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list cards short 2> /dev/null)
}
__docker_append_to_completions () 
{ 
    COMPREPLY=(${COMPREPLY[@]/%/"$1"})
}
__docker_complete_capabilities_addable () 
{ 
    COMPREPLY=($( compgen -W "
		ALL
		AUDIT_CONTROL
		BLOCK_SUSPEND
		DAC_READ_SEARCH
		IPC_LOCK
		IPC_OWNER
		LEASE
		LINUX_IMMUTABLE
		MAC_ADMIN
		MAC_OVERRIDE
		NET_ADMIN
		NET_BROADCAST
		SYS_ADMIN
		SYS_BOOT
		SYSLOG
		SYS_MODULE
		SYS_NICE
		SYS_PACCT
		SYS_PTRACE
		SYS_RAWIO
		SYS_RESOURCE
		SYS_TIME
		SYS_TTY_CONFIG
		WAKE_ALARM
	" -- "$cur" ))
}
__docker_complete_capabilities_droppable () 
{ 
    COMPREPLY=($( compgen -W "
		ALL
		AUDIT_WRITE
		CHOWN
		DAC_OVERRIDE
		FOWNER
		FSETID
		KILL
		MKNOD
		NET_BIND_SERVICE
		NET_RAW
		SETFCAP
		SETGID
		SETPCAP
		SETUID
		SYS_CHROOT
	" -- "$cur" ))
}
__docker_complete_configs () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_configs "$@")" -- "$current"))
}
__docker_complete_container_ids () 
{ 
    local containers=($(__docker_q ps -aq));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_container_names () 
{ 
    local containers=($(__docker_q ps -aq --no-trunc));
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    COMPREPLY=($(compgen -W "${names[*]}" -- "$cur"))
}
__docker_complete_containers () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_containers "$@")" -- "$current"))
}
__docker_complete_containers_all () 
{ 
    __docker_complete_containers "$@" --all
}
__docker_complete_containers_in_network () 
{ 
    local containers=($(__docker_q network inspect -f '{{range $i, $c := .Containers}}{{$i}} {{$c.Name}} {{end}}' "$1"));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_containers_removable () 
{ 
    __docker_complete_containers "$@" --filter status=created --filter status=exited
}
__docker_complete_containers_running () 
{ 
    __docker_complete_containers "$@" --filter status=running
}
__docker_complete_containers_stopped () 
{ 
    __docker_complete_containers "$@" --filter status=exited
}
__docker_complete_containers_unpauseable () 
{ 
    __docker_complete_containers "$@" --filter status=paused
}
__docker_complete_detach_keys () 
{ 
    case "$prev" in 
        --detach-keys)
            case "$cur" in 
                *,)
                    COMPREPLY=($( compgen -W "${cur}ctrl-" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "ctrl-" -- "$cur" ))
                ;;
            esac;
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_images () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_images "$@")" -- "$current"));
    __ltrim_colon_completions "$current"
}
__docker_complete_isolation () 
{ 
    COMPREPLY=($( compgen -W "default hyperv process" -- "$cur" ))
}
__docker_complete_local_interfaces () 
{ 
    local additional_interface;
    if [ "$1" = "--add" ]; then
        additional_interface="$2";
        shift 2;
    fi;
    COMPREPLY=($( compgen -W "$(__docker_local_interfaces "$@") $additional_interface" -- "$cur" ))
}
__docker_complete_local_ips () 
{ 
    __docker_complete_local_interfaces --ip-only
}
__docker_complete_log_driver_options () 
{ 
    local key=$(__docker_map_key_of_current_option '--log-opt');
    case "$key" in 
        awslogs-create-group)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        awslogs-credentials-endpoint)
            COMPREPLY=($( compgen -W "/" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        fluentd-async-connect)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        fluentd-sub-second-precision)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        gelf-address)
            COMPREPLY=($( compgen -W "tcp udp" -S "://" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        gelf-compression-level)
            COMPREPLY=($( compgen -W "1 2 3 4 5 6 7 8 9" -- "${cur##*=}" ));
            return
        ;;
        gelf-compression-type)
            COMPREPLY=($( compgen -W "gzip none zlib" -- "${cur##*=}" ));
            return
        ;;
        line-only)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        mode)
            COMPREPLY=($( compgen -W "blocking non-blocking" -- "${cur##*=}" ));
            return
        ;;
        syslog-address)
            COMPREPLY=($( compgen -W "tcp:// tcp+tls:// udp:// unix://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        syslog-facility)
            COMPREPLY=($( compgen -W "
				auth
				authpriv
				cron
				daemon
				ftp
				kern
				local0
				local1
				local2
				local3
				local4
				local5
				local6
				local7
				lpr
				mail
				news
				syslog
				user
				uucp
			" -- "${cur##*=}" ));
            return
        ;;
        syslog-format)
            COMPREPLY=($( compgen -W "rfc3164 rfc5424 rfc5424micro" -- "${cur##*=}" ));
            return
        ;;
        syslog-tls-ca-cert | syslog-tls-cert | syslog-tls-key)
            _filedir;
            return
        ;;
        syslog-tls-skip-verify)
            COMPREPLY=($( compgen -W "true" -- "${cur##*=}" ));
            return
        ;;
        splunk-url)
            COMPREPLY=($( compgen -W "http:// https://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        splunk-gzip | splunk-insecureskipverify | splunk-verify-connection)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        splunk-format)
            COMPREPLY=($( compgen -W "inline json raw" -- "${cur##*=}" ));
            return
        ;;
    esac;
    return 1
}
__docker_complete_log_drivers () 
{ 
    COMPREPLY=($( compgen -W "
		awslogs
		etwlogs
		fluentd
		gcplogs
		gelf
		journald
		json-file
		logentries
		none
		splunk
		syslog
	" -- "$cur" ))
}
__docker_complete_log_levels () 
{ 
    COMPREPLY=($( compgen -W "debug info warn error fatal" -- "$cur" ))
}
__docker_complete_log_options () 
{ 
    local common_options1="max-buffer-size mode";
    local common_options2="env env-regex labels";
    local awslogs_options="$common_options1 awslogs-create-group awslogs-credentials-endpoint awslogs-datetime-format awslogs-group awslogs-multiline-pattern awslogs-region awslogs-stream tag";
    local fluentd_options="$common_options1 $common_options2 fluentd-address fluentd-async-connect fluentd-buffer-limit fluentd-retry-wait fluentd-max-retries fluentd-sub-second-precision tag";
    local gcplogs_options="$common_options1 $common_options2 gcp-log-cmd gcp-meta-id gcp-meta-name gcp-meta-zone gcp-project";
    local gelf_options="$common_options1 $common_options2 gelf-address gelf-compression-level gelf-compression-type gelf-tcp-max-reconnect gelf-tcp-reconnect-delay tag";
    local journald_options="$common_options1 $common_options2 tag";
    local json_file_options="$common_options1 $common_options2 max-file max-size";
    local logentries_options="$common_options1 $common_options2 line-only logentries-token tag";
    local splunk_options="$common_options1 $common_options2 splunk-caname splunk-capath splunk-format splunk-gzip splunk-gzip-level splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url splunk-verify-connection tag";
    local syslog_options="$common_options1 $common_options2 syslog-address syslog-facility syslog-format syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify tag";
    local all_options="$fluentd_options $gcplogs_options $gelf_options $journald_options $logentries_options $json_file_options $syslog_options $splunk_options";
    case $(__docker_value_of_option --log-driver) in 
        '')
            COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
        ;;
        awslogs)
            COMPREPLY=($( compgen -W "$awslogs_options" -S = -- "$cur" ))
        ;;
        fluentd)
            COMPREPLY=($( compgen -W "$fluentd_options" -S = -- "$cur" ))
        ;;
        gcplogs)
            COMPREPLY=($( compgen -W "$gcplogs_options" -S = -- "$cur" ))
        ;;
        gelf)
            COMPREPLY=($( compgen -W "$gelf_options" -S = -- "$cur" ))
        ;;
        journald)
            COMPREPLY=($( compgen -W "$journald_options" -S = -- "$cur" ))
        ;;
        json-file)
            COMPREPLY=($( compgen -W "$json_file_options" -S = -- "$cur" ))
        ;;
        logentries)
            COMPREPLY=($( compgen -W "$logentries_options" -S = -- "$cur" ))
        ;;
        syslog)
            COMPREPLY=($( compgen -W "$syslog_options" -S = -- "$cur" ))
        ;;
        splunk)
            COMPREPLY=($( compgen -W "$splunk_options" -S = -- "$cur" ))
        ;;
        *)
            return
        ;;
    esac;
    __docker_nospace
}
__docker_complete_networks () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_networks "$@")" -- "$current"))
}
__docker_complete_nodes () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_nodes "$@")" -- "$current"))
}
__docker_complete_plugins_bundled () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_bundled "$@")" -- "$current"))
}
__docker_complete_plugins_installed () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_installed "$@")" -- "$current"))
}
__docker_complete_resolved_hostname () 
{ 
    command -v host > /dev/null 2>&1 || return;
    COMPREPLY=($(host 2>/dev/null "${cur%:}" | awk '/has address/ {print $4}'))
}
__docker_complete_restart () 
{ 
    case "$prev" in 
        --restart)
            case "$cur" in 
                on-failure:*)

                ;;
                *)
                    COMPREPLY=($( compgen -W "always no on-failure on-failure: unless-stopped" -- "$cur"))
                ;;
            esac;
            return
        ;;
    esac;
    return 1
}
__docker_complete_runtimes () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_runtimes)" -- "$cur"))
}
__docker_complete_secrets () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_secrets "$@")" -- "$current"))
}
__docker_complete_services () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_services "$@")" -- "$current"))
}
__docker_complete_services_and_tasks () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_services "$@") $(__docker_tasks)" -- "$cur"))
}
__docker_complete_signals () 
{ 
    local signals=(SIGCONT SIGHUP SIGINT SIGKILL SIGQUIT SIGSTOP SIGTERM SIGUSR1 SIGUSR2);
    COMPREPLY=($( compgen -W "${signals[*]} ${signals[*]#SIG}" -- "$( echo "$cur" | tr '[:lower:]' '[:upper:]')" ))
}
__docker_complete_stack_orchestrator_options () 
{ 
    case "$prev" in 
        --kubeconfig)
            _filedir;
            return 0
        ;;
        --namespace)
            return 0
        ;;
        --orchestrator)
            COMPREPLY=($( compgen -W "all kubernetes swarm" -- "$cur"));
            return 0
        ;;
    esac;
    return 1
}
__docker_complete_stacks () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_stacks "$@")" -- "$current"))
}
__docker_complete_user_group () 
{ 
    if [[ $cur == *:* ]]; then
        COMPREPLY=($(compgen -g -- "${cur#*:}"));
    else
        COMPREPLY=($(compgen -u -S : -- "$cur"));
        __docker_nospace;
    fi
}
__docker_complete_volumes () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_volumes "$@")" -- "$current"))
}
__docker_compose_complete_running_services () 
{ 
    local names=$(__docker_compose_complete_services --filter status=running);
    COMPREPLY=($(compgen -W "$names" -- "$cur"))
}
__docker_compose_complete_services () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_compose_services "$@")" -- "$cur"))
}
__docker_compose_has_option () 
{ 
    local pattern="$1";
    for ((i=2; i < $cword; ++i))
    do
        if [[ ${words[$i]} =~ ^($pattern)$ ]]; then
            return 0;
        fi;
    done;
    return 1
}
__docker_compose_map_key_of_current_option () 
{ 
    local glob="$1";
    local key glob_pos;
    if [ "$cur" = "=" ]; then
        key="$prev";
        glob_pos=$((cword - 2));
    else
        if [[ $cur == *=* ]]; then
            key=${cur%=*};
            glob_pos=$((cword - 1));
        else
            if [ "$prev" = "=" ]; then
                key=${words[$cword - 2]};
                glob_pos=$((cword - 3));
            else
                return;
            fi;
        fi;
    fi;
    [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--));
    [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}
__docker_compose_nospace () 
{ 
    type compopt &> /dev/null && compopt -o nospace
}
__docker_compose_q () 
{ 
    docker-compose "${top_level_options[@]}" "$@" 2> /dev/null
}
__docker_compose_services () 
{ 
    __docker_compose_q ps --services "$@"
}
__docker_compose_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}
__docker_compose_to_extglob () 
{ 
    local extglob=$( __docker_compose_to_alternatives "$1" );
    echo "@($extglob)"
}
__docker_configs () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "$DOCKER_COMPLETION_SHOW_CONFIG_IDS" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q config ls --format "$format" "$@"
}
__docker_containers () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Names}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_CONTAINER_IDS}" = yes ]; then
                format='{{.ID}} {{.Names}}';
            else
                format='{{.Names}}';
            fi;
        fi;
    fi;
    __docker_q ps --format "$format" "$@"
}
__docker_containers_all () 
{ 
    local containers="$( __docker_q ps -a -q )";
    local names="$( __docker_q inspect --format '{{.Name}}' $containers | sed 's,^/,,' )";
    COMPREPLY=($( compgen -W "$names $containers" -- "$cur" ))
}
__docker_containers_and_images () 
{ 
    local containers="$( __docker_q ps -a -q )";
    local names="$( __docker_q inspect --format '{{.Name}}' $containers | sed 's,^/,,' )";
    local repos="$( __docker_q images | awk 'NR>1{print $1}' | grep -v '^<none>$' )";
    local images="$( __docker_q images | awk 'NR>1{print $1":"$2}' | grep -v '^<none>:' )";
    local ids="$( __docker_q images -a -q )";
    COMPREPLY=($( compgen -W "$containers $names $repos $images $ids" -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
__docker_containers_running () 
{ 
    local containers="$( __docker_q ps -q )";
    local names="$( __docker_q inspect --format '{{.Name}}' $containers | sed 's,^/,,' )";
    COMPREPLY=($( compgen -W "$names $containers" -- "$cur" ))
}
__docker_containers_stopped () 
{ 
    local containers="$( { __docker_q ps -a -q; __docker_q ps -q; } | sort | uniq -u )";
    local names="$( __docker_q inspect --format '{{.Name}}' $containers | sed 's,^/,,' )";
    COMPREPLY=($( compgen -W "$names $containers" -- "$cur" ))
}
__docker_daemon_is_experimental () 
{ 
    [ "$(__docker_q version -f '{{.Server.Experimental}}')" = "true" ]
}
__docker_daemon_os_is () 
{ 
    local expected_os="$1";
    local actual_os=${daemon_os=$(__docker_q version -f '{{.Server.Os}}')};
    [ "$actual_os" = "$expected_os" ]
}
__docker_image_repos () 
{ 
    local repos="$( __docker_q images | awk 'NR>1{print $1}' | grep -v '^<none>$' )";
    COMPREPLY=($( compgen -W "$repos" -- "$cur" ))
}
__docker_image_repos_and_tags () 
{ 
    local repos="$( __docker_q images | awk 'NR>1{print $1}' | grep -v '^<none>$' )";
    local images="$( __docker_q images | awk 'NR>1{print $1":"$2}' | grep -v '^<none>:' )";
    COMPREPLY=($( compgen -W "$repos $images" -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
__docker_image_repos_and_tags_and_ids () 
{ 
    local repos="$( __docker_q images | awk 'NR>1{print $1}' | grep -v '^<none>$' )";
    local images="$( __docker_q images | awk 'NR>1{print $1":"$2}' | grep -v '^<none>:' )";
    local ids="$( __docker_q images -a -q )";
    COMPREPLY=($( compgen -W "$repos $images $ids" -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
__docker_images () 
{ 
    local repo_format='{{.Repository}}';
    local tag_format='{{.Repository}}:{{.Tag}}';
    local id_format='{{.ID}}';
    local all;
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" = "all" ]; then
        all='--all';
    fi;
    while true; do
        case "$1" in 
            --repo)
                format+="$repo_format\n";
                shift
            ;;
            --tag)
                if [ "${DOCKER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
                    format+="$tag_format\n";
                fi;
                shift
            ;;
            --id)
                if [[ $DOCKER_COMPLETION_SHOW_IMAGE_IDS =~ ^(all|non-intermediate)$ ]]; then
                    format+="$id_format\n";
                fi;
                shift
            ;;
            --force-tag)
                format+="$tag_format\n";
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    __docker_q image ls --no-trunc --format "${format%\\n}" $all "$@" | grep --color=auto -v '<none>$'
}
__docker_local_interfaces () 
{ 
    command -v ip > /dev/null 2>&1 || return;
    local format;
    if [ "$1" = "--ip-only" ]; then
        format='\1';
        shift;
    else
        format='\1 \2';
    fi;
    ip addr show scope global 2> /dev/null | sed -n "s| \+inet \([0-9.]\+\).* \([^ ]\+\)|$format|p"
}
__docker_map_key_of_current_option () 
{ 
    local glob="$1";
    local key glob_pos;
    if [ "$cur" = "=" ]; then
        key="$prev";
        glob_pos=$((cword - 2));
    else
        if [[ $cur == *=* ]]; then
            key=${cur%=*};
            glob_pos=$((cword - 1));
        else
            if [ "$prev" = "=" ]; then
                key=${words[$cword - 2]};
                glob_pos=$((cword - 3));
            else
                return;
            fi;
        fi;
    fi;
    [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--));
    [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}
__docker_networks () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_NETWORK_IDS}" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q network ls --format "$format" "$@"
}
__docker_nodes () 
{ 
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_NODE_IDS" = yes ]; then
        format='{{.ID}} {{.Hostname}}';
    else
        format='{{.Hostname}}';
    fi;
    local add=();
    while true; do
        case "$1" in 
            --id)
                format='{{.ID}}';
                shift
            ;;
            --name)
                format='{{.Hostname}}';
                shift
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    echo "$(__docker_q node ls --format "$format" "$@")" "${add[@]}"
}
__docker_nospace () 
{ 
    type compopt &> /dev/null && compopt -o nospace
}
__docker_plugins_bundled () 
{ 
    local type add=() remove=();
    while true; do
        case "$1" in 
            --type)
                type="$2";
                shift 2
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            --remove)
                remove+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    local plugins=($(__docker_q info --format "{{range \$i, \$p := .Plugins.$type}}{{.}} {{end}}"));
    for del in "${remove[@]}";
    do
        plugins=(${plugins[@]/$del/});
    done;
    echo "${plugins[@]}" "${add[@]}"
}
__docker_plugins_installed () 
{ 
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_PLUGIN_IDS" = yes ]; then
        format='{{.ID}} {{.Name}}';
    else
        format='{{.Name}}';
    fi;
    __docker_q plugin ls --format "$format" "$@"
}
__docker_pos_first_nonflag () 
{ 
    local argument_flags=$1;
    local counter=$cpos;
    while [ $counter -le $cword ]; do
        if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
            (( counter++ ));
        else
            case "${words[$counter]}" in 
                -*)

                ;;
                *)
                    break
                ;;
            esac;
        fi;
        (( counter++ ));
    done;
    echo $counter
}
__docker_q () 
{ 
    docker.io "$@" 2> /dev/null
}
__docker_runtimes () 
{ 
    __docker_q info | sed -n 's/^Runtimes: \(.*\)/\1/p'
}
__docker_secrets () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "$DOCKER_COMPLETION_SHOW_SECRET_IDS" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q secret ls --format "$format" "$@"
}
__docker_services () 
{ 
    local fields='$2';
    [ "${DOCKER_COMPLETION_SHOW_SERVICE_IDS}" = yes ] && fields='$1,$2';
    if [ "$1" = "--id" ]; then
        fields='$1';
        shift;
    else
        if [ "$1" = "--name" ]; then
            fields='$2';
            shift;
        fi;
    fi;
    __docker_q service ls "$@" | awk "NR>1 {print $fields}"
}
__docker_stack_orchestrator_is () 
{ 
    case "$1" in 
        kubernetes)
            if [ -z "$stack_orchestrator_is_kubernetes" ]; then
                __docker_q stack ls --help | grep --color=auto -qe --namespace;
                stack_orchestrator_is_kubernetes=$?;
            fi;
            return $stack_orchestrator_is_kubernetes
        ;;
        swarm)
            if [ -z "$stack_orchestrator_is_swarm" ]; then
                __docker_q stack deploy --help | grep --color=auto -qe "with-registry-auth";
                stack_orchestrator_is_swarm=$?;
            fi;
            return $stack_orchestrator_is_swarm
        ;;
        *)
            return 1
        ;;
    esac
}
__docker_stacks () 
{ 
    __docker_q stack ls | awk 'NR>1 {print $1}'
}
__docker_subcommands () 
{ 
    local subcommands="$1";
    local counter=$((command_pos + 1));
    while [ "$counter" -lt "$cword" ]; do
        case "${words[$counter]}" in 
            $(__docker_to_extglob "$subcommands"))
                subcommand_pos=$counter;
                local subcommand=${words[$counter]};
                local completions_func=_docker_${command}_${subcommand//-/_};
                declare -F "$completions_func" > /dev/null && "$completions_func";
                return 0
            ;;
        esac;
        (( counter++ ));
    done;
    return 1
}
__docker_tasks () 
{ 
    __docker_q service ps --format '{{.ID}}' ""
}
__docker_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}
__docker_to_extglob () 
{ 
    local extglob=$( __docker_to_alternatives "$1" );
    echo "@($extglob)"
}
__docker_value_of_option () 
{ 
    local option_extglob=$(__docker_to_extglob "$1");
    local counter=$((command_pos + 1));
    while [ "$counter" -lt "$cword" ]; do
        case ${words[$counter]} in 
            $option_extglob)
                echo "${words[$counter + 1]}";
                break
            ;;
        esac;
        (( counter++ ));
    done
}
__docker_volumes () 
{ 
    __docker_q volume ls -q "$@"
}
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        if [[ ${!1} == */* ]]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                index=$(( index - old_size + new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_ps1 () 
{ 
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return
        ;;
    esac;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        if [ $pcmode = yes ]; then
            PS1="$ps1pc_start$ps1pc_end";
        fi;
        return;
    fi;
    local short_sha;
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        read b 2> /dev/null < "$g/rebase-merge/head-name";
        read step 2> /dev/null < "$g/rebase-merge/msgnum";
        read total 2> /dev/null < "$g/rebase-merge/end";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            read step 2> /dev/null < "$g/rebase-apply/next";
            read total 2> /dev/null < "$g/rebase-apply/last";
            if [ -f "$g/rebase-apply/rebasing" ]; then
                read b 2> /dev/null < "$g/rebase-apply/head-name";
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! read head 2> /dev/null < "$g/HEAD"; then
                    if [ $pcmode = yes ]; then
                        PS1="$ps1pc_start$ps1pc_end";
                    fi;
                    return;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet --exit-code || w="*";
                if [ -n "$short_sha" ]; then
                    git diff-index --cached --quiet HEAD -- || i="+";
                else
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && [ -r "$g/refs/stash" ]; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --error-unmatch -- '*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    local f="$w$i$s$u";
    local gitstring="$c${b##refs/heads/}${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            p="$p $(git rev-parse --abbrev-ref "$upstream" 2>/dev/null)";
        fi;
    fi
}
__grub_dir () 
{ 
    local i c=1 boot_dir;
    for ((c=1; c <= ${#COMP_WORDS[@]}; c++ ))
    do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --boot-directory)
                c=$((++c));
                i="${COMP_WORDS[c]}";
                boot_dir="${i##*=}";
                break
            ;;
        esac;
    done;
    boot_dir=${boot_dir-/boot};
    echo "${boot_dir%/}/grub"
}
__grub_get_last_option () 
{ 
    local i;
    for ((i=$COMP_CWORD-1; i > 0; i-- ))
    do
        if [[ "${COMP_WORDS[i]}" == -* ]]; then
            echo "${COMP_WORDS[i]}";
            break;
        fi;
    done
}
__grub_get_options_from_help () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --help);
    do
        case $i in 
            --*)
                echo "${i%=*}"
            ;;
        esac;
    done
}
__grub_get_options_from_usage () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --usage);
    do
        case $i in 
            \[--*\])
                i=${i#[};
                echo ${i%%?(=*)]}
            ;;
        esac;
    done
}
__grub_list_menuentries () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local config_file=$(__grub_dir)/grub.cfg;
    if [ -f "$config_file" ]; then
        local IFS='
';
        COMPREPLY=($(compgen             -W "$( awk -F "[\"']" '/menuentry/ { print $2 }' $config_file )"             -- "$cur" ));
    fi
}
__grub_list_modules () 
{ 
    local grub_dir=$(__grub_dir);
    local IFS='
';
    COMPREPLY=($( compgen -f -X '!*/*.mod' -- "${grub_dir}/$cur" | {
         while read -r tmp; do
             [ -n $tmp ] && {
                 tmp=${tmp##*/}
                 printf '%s\n' ${tmp%.mod}
             }
         done
         }
        ))
}
__grubcomp () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS=' ''	''
';
            COMPREPLY=($(compgen -P "${2-}" -W "${1-}" -S "${4-}" -- "$cur"))
        ;;
    esac
}
__loaded_modules () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list modules short 2> /dev/null)
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    for i in $1;
    do
        case $i in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__ports () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tPorts:/ {
            flag=1; next
         }

         /^\t[A-Za-z]/ {
             flag=0
         }

         flag {
             if (/^\t\t[A-Za-z]/)
                 ports = ports substr($0, 3, index($0, ":")-3) " "
         }

         END {
             print ports
         }'
}
__profiles () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tProfiles:/ {
            flag=1; next
        }

        /^\t[A-Za-z]/ {
            flag=0
        }

        flag {
            if (/^\t\t[A-Za-z]/)
                profiles = profiles substr($0, 3, index($0, ": ")-3) " "
        }

        END {
            print profiles
        }'
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [' 	']* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [[ $i == $COMP_CWORD ]] && eval $3=$j;
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [' 	']* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
        [[ $i == $COMP_CWORD ]] && eval $3=$j;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__resample_methods () 
{ 
    while read name; do
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-resample-methods 2> /dev/null)
}
__sink_inputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sink-inputs short 2> /dev/null)
}
__sinks () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sinks short 2> /dev/null)
}
__sinks_idx () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sinks short 2> /dev/null)
}
__source_outputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list source-outputs short 2> /dev/null)
}
__sources () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sources short 2> /dev/null)
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
_available_interfaces () 
{ 
    local cmd PATH=$PATH:/sbin;
    if [[ ${1:-} == -w ]]; then
        cmd="iwconfig";
    else
        if [[ ${1:-} == -a ]]; then
            cmd="{ ifconfig || ip link show up; }";
        else
            cmd="{ ifconfig -a || ip link show; }";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_axi_cache () 
{ 
    local cur prev cmd;
    COMPREPLY=();
    COMP_WORDBREAKS=${COMP_WORDBREAKS//:};
    type _get_comp_words_by_ref &> /dev/null && { 
        _get_comp_words_by_ref -n: cur prev
    } || { 
        cur=$(_get_cword ":");
        prev=${COMP_WORDS[$COMP_CWORD-1]}
    };
    cmd=${COMP_WORDS[1]};
    case "$prev" in 
        *axi-cache*)
            COMPREPLY=($(compgen -W "help more search show again showpkg showsrc depends rdepends policy madison" -- "$cur"));
            return 0
        ;;
        --sort)
            COMPREPLY=($(compgen -W "$(egrep ^[a-z] /var/lib/apt-xapian-index/values | awk -F"\t" '{print $1}')" -- "$cur"));
            return 0
        ;;
    esac;
    case "$cmd" in 
        search | again)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--sort --tags" -- "$cur"));
                return 0;
            fi
        ;;
        show | showpkg | showsrc | depends | rdepends | policy | madison)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--last" -- "$cur"));
                return 0;
            fi
        ;;
        *)
            return 0
        ;;
    esac;
    if [ -n "$cur" ]; then
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=partial)" -- "$cur"));
    else
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=plain)" -- "$cur"));
    fi;
    return 0
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_cmake () 
{ 
    local cur prev words cword split=false;
    _init_completion -n := || return;
    local prefix=;
    if [[ $cur == -D* ]]; then
        prev=-D;
        prefix=-D;
        cur="${cur#-D}";
    else
        if [[ $cur == -U* ]]; then
            prev=-U;
            prefix=-U;
            cur="${cur#-U}";
        fi;
    fi;
    case "$prev" in 
        -D)
            if [[ $cur == *=* ]]; then
                local var type value;
                var="${cur%%[:=]*}";
                value="${cur#*=}";
                if [[ $cur == CMAKE_BUILD_TYPE* ]]; then
                    COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                        MinSizeRel' -- "$value" ));
                    return;
                fi;
                if [[ $cur == *:* ]]; then
                    type="${cur#*:}";
                    type="${type%%=*}";
                else
                    type=$( cmake -LA -N 2>/dev/null | grep "$var:"                         2>/dev/null );
                    type="${type#*:}";
                    type="${type%%=*}";
                fi;
                case "$type" in 
                    FILEPATH)
                        cur="$value";
                        _filedir;
                        return
                    ;;
                    PATH)
                        cur="$value";
                        _filedir -d;
                        return
                    ;;
                    BOOL)
                        COMPREPLY=($( compgen -W 'ON OFF TRUE FALSE' --                             "$value" ));
                        return
                    ;;
                    STRING | INTERNAL)
                        return
                    ;;
                esac;
            else
                if [[ $cur == *:* ]]; then
                    local type="${cur#*:}";
                    COMPREPLY=($( compgen -W 'FILEPATH PATH STRING BOOL INTERNAL'                    -S = -- "$type" ));
                    compopt -o nospace;
                else
                    COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                    cut -f1 -d: )' -P "$prefix" -- "$cur" ));
                    compopt -o nospace;
                fi;
            fi;
            return
        ;;
        -U)
            COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                cut -f1 -d: )' -P "$prefix" -- "$cur" ));
            return
        ;;
    esac;
    _split_longopt && split=true;
    case "$prev" in 
        -C | -P | --graphviz | --system-information)
            _filedir;
            return
        ;;
        --build)
            _filedir -d;
            return
        ;;
        -E)
            COMPREPLY=($( compgen -W "$( cmake -E help |& sed -n                 '/^  /{s|^  \([^ ]\{1,\}\) .*$|\1|;p}' 2>/dev/null )"                 -- "$cur" ));
            return
        ;;
        -G)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            COMPREPLY=($( compgen -W '$( cmake --help 2>/dev/null | sed -n \
                -e "1,/^Generators/d" \
                -e "/^  *[^ =]/{s|^ *\([^=]*[^ =]\).*$|\1|;s| |\\\\ |g;p}" \
                2>/dev/null )' -- "$quoted" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cmake --help-command-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( cmake --help-module-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( cmake --help-policies 2>/dev/null |
                grep "^  CMP" 2>/dev/null )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( cmake --help-property-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cmake --help-variable-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($( compgen -d -c -- "$cur" ));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$( complete -p $cmd 2>/dev/null );
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$( complete -p $compcmd 2>/dev/null );
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    complete -F _minimal "$1" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cpack () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -G)
            COMPREPLY=($( compgen -W '$( cpack --help 2>/dev/null |
                sed -e "1,/^Generators/d" -e "s|^ *\([^ ]*\) .*$|\1|" \
                2>/dev/null )' -- "$cur" ));
            return
        ;;
        -C)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -D)
            [[ $cur == *=* ]] && return;
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -S = -- "$cur" ));
            compopt -o nospace;
            return
        ;;
        -P | -R | --vendor)
            return
        ;;
        -B)
            _filedir -d;
            return
        ;;
        --config)
            _filedir;
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cpack --help-command-list 2>/dev/null|
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_ctest () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -C | --build-config)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -j | --parallel)
            COMPREPLY=($( compgen -W "{1..$(( $(_ncpus)*2 ))}" -- "$cur" ));
            return
        ;;
        -O | --output-log | -A | --add-notes | --extra-submit)
            _filedir;
            return
        ;;
        -L | --label-regex | -LE | --label-exclude | --track | -I | --tests-information | --max-width | --timeout | --stop-time)
            return
        ;;
        -R | --tests-regex | -E | --exclude-regex)
            COMPREPLY=($( compgen -W '$( ctest -N 2>/dev/null |
                grep "^  Test" 2>/dev/null | cut -d: -f 2 )' -- "$cur" ));
            return
        ;;
        -D | --dashboard)
            if [[ $cur == @(Experimental|Nightly|Continuous)* ]]; then
                local model action;
                action=${cur#@(Experimental|Nightly|Continuous)};
                model=${cur%"$action"};
                COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                    Coverage Submit MemCheck' -P "$model" -- "$action" ));
            else
                COMPREPLY=($( compgen -W 'Experimental Nightly Continuous'                 -- "$cur" ));
                compopt -o nospace;
            fi;
            return
        ;;
        -M | --test-model)
            COMPREPLY=($( compgen -W 'Experimental Nightly Continuous' --                 "$cur" ));
            return
        ;;
        -T | --test-action)
            COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                Coverage Submit MemCheck' -- "$cur" ));
            return
        ;;
        -S | --script | -SP | --script-new-process)
            _filedir '@(cmake|ctest)';
            return
        ;;
        --interactive-debug-mode)
            COMPREPLY=($( compgen -W '0 1' -- "$cur" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( ctest --help-command-list 2>/dev/null|
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_debconf_show () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
_desktop_file_validate () 
{ 
    COMPRELY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _filedir '@(desktop)'
}
_docker () 
{ 
    local commands="
			attach
			build
			commit
			cp
			diff
			events
			export
			history
			images
			import
			info
			insert
			inspect
			kill
			load
			login
			logs
			port
			ps
			pull
			push
			restart
			rm
			rmi
			run
			save
			search
			start
			stop
			tag
			top
			version
			wait
		";
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref -n : cur prev words cword;
    local command='docker';
    local counter=1;
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in 
            -H)
                (( counter++ ))
            ;;
            -*)

            ;;
            *)
                command="${words[$counter]}";
                cpos=$counter;
                (( cpos++ ));
                break
            ;;
        esac;
        (( counter++ ));
    done;
    local completions_func=_docker_${command};
    declare -F $completions_func > /dev/null && $completions_func;
    return 0
}
_docker_attach () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--no-stdin --sig-proxy" -- "$cur" ))
        ;;
        *)
            local counter="$(__docker_pos_first_nonflag)";
            if [ $cword -eq $counter ]; then
                __docker_containers_running;
            fi
        ;;
    esac
}
_docker_build () 
{ 
    case "$prev" in 
        -t | --tag)
            __docker_image_repos_and_tags;
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-t --tag -q --quiet --no-cache --rm" -- "$cur" ))
        ;;
        *)
            local counter="$(__docker_pos_first_nonflag '-t|--tag')";
            if [ $cword -eq $counter ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_checkpoint () 
{ 
    local subcommands="
		create
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_checkpoint_create () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help --leave-running" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_checkpoint_ls () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_checkpoint_rm () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    COMPREPLY=($( compgen -W "$(__docker_q checkpoint ls "$prev" | sed 1d)" -- "$cur" ));
                fi;
            fi
        ;;
    esac
}
_docker_commit () 
{ 
    case "$prev" in 
        -m | --message | -a | --author | --run)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-m --message -a --author --run" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '-m|--message|-a|--author|--run');
            if [ $cword -eq $counter ]; then
                __docker_containers_all;
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_compose () 
{ 
    local previous_extglob_setting=$(shopt -p extglob);
    shopt -s extglob;
    local commands=(build bundle config create down events exec help images kill logs pause port ps pull push restart rm run scale start stop top unpause up version);
    local daemon_boolean_options="
		--skip-hostname-check
		--tls
		--tlsverify
	";
    local daemon_options_with_args="
		--file -f
		--host -H
		--project-directory
		--project-name -p
		--tlscacert
		--tlscert
		--tlskey
	";
    local top_level_options_with_args="
		--log-level
	";
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref -n : cur prev words cword;
    local command='docker_compose';
    local top_level_options=();
    local counter=1;
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in 
            $(__docker_compose_to_extglob "$daemon_boolean_options"))
                local opt=${words[counter]};
                top_level_options+=($opt)
            ;;
            $(__docker_compose_to_extglob "$daemon_options_with_args"))
                local opt=${words[counter]};
                local arg=${words[++counter]};
                top_level_options+=($opt $arg)
            ;;
            $(__docker_compose_to_extglob "$top_level_options_with_args"))
                (( counter++ ))
            ;;
            -*)

            ;;
            *)
                command="${words[$counter]}";
                break
            ;;
        esac;
        (( counter++ ));
    done;
    local completions_func=_docker_compose_${command//-/_};
    declare -F $completions_func > /dev/null && $completions_func;
    eval "$previous_extglob_setting";
    return 0
}
_docker_compose_build () 
{ 
    case "$prev" in 
        --build-arg)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_compose_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--build-arg --compress --force-rm --help --memory --no-cache --pull" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services --filter source=build
        ;;
    esac
}
_docker_compose_bundle () 
{ 
    case "$prev" in 
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    COMPREPLY=($( compgen -W "--push-images --help --output -o" -- "$cur" ))
}
_docker_compose_config () 
{ 
    COMPREPLY=($( compgen -W "--help --quiet -q --resolve-image-digests --services --volumes" -- "$cur" ))
}
_docker_compose_create () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--build --force-recreate --help --no-build --no-recreate" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_docker_compose () 
{ 
    case "$prev" in 
        --tlscacert | --tlscert | --tlskey)
            _filedir;
            return
        ;;
        --file | -f)
            _filedir "y?(a)ml";
            return
        ;;
        --log-level)
            COMPREPLY=($( compgen -W "debug info warning error critical" -- "$cur" ));
            return
        ;;
        --project-directory)
            _filedir -d;
            return
        ;;
        $(__docker_compose_to_extglob "$daemon_options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$daemon_boolean_options $daemon_options_with_args $top_level_options_with_args --help -h --no-ansi --verbose --version -v" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "${commands[*]}" -- "$cur" ))
        ;;
    esac
}
_docker_compose_down () 
{ 
    case "$prev" in 
        --rmi)
            COMPREPLY=($( compgen -W "all local" -- "$cur" ));
            return
        ;;
        --timeout | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --rmi --timeout -t --volumes -v --remove-orphans" -- "$cur" ))
        ;;
    esac
}
_docker_compose_events () 
{ 
    case "$prev" in 
        --json)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --json" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_exec () 
{ 
    case "$prev" in 
        --index | --user | -u | --workdir | -w)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-d --detach --help --index --privileged -T --user -u --workdir -w" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_running_services
        ;;
    esac
}
_docker_compose_help () 
{ 
    COMPREPLY=($( compgen -W "${commands[*]}" -- "$cur" ))
}
_docker_compose_images () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_kill () 
{ 
    case "$prev" in 
        -s)
            COMPREPLY=($( compgen -W "SIGHUP SIGINT SIGKILL SIGUSR1 SIGUSR2" -- "$(echo $cur | tr '[:lower:]' '[:upper:]')" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help -s" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_running_services
        ;;
    esac
}
_docker_compose_logs () 
{ 
    case "$prev" in 
        --tail)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--follow -f --help --no-color --tail --timestamps -t" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_pause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_running_services
        ;;
    esac
}
_docker_compose_port () 
{ 
    case "$prev" in 
        --protocol)
            COMPREPLY=($( compgen -W "tcp udp" -- "$cur" ));
            return
        ;;
        --index)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --index --protocol" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_ps () 
{ 
    local key=$(__docker_compose_map_key_of_current_option '--filter');
    case "$key" in 
        source)
            COMPREPLY=($( compgen -W "build image" -- "${cur##*=}" ));
            return
        ;;
        status)
            COMPREPLY=($( compgen -W "paused restarting running stopped" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "source status" -S "=" -- "$cur" ));
            __docker_compose_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --services --filter" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_pull () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --ignore-pull-failures --include-deps --no-parallel --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services --filter source=image
        ;;
    esac
}
_docker_compose_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --ignore-push-failures" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_restart () 
{ 
    case "$prev" in 
        --timeout | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --timeout -t" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_running_services
        ;;
    esac
}
_docker_compose_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --stop -s -v" -- "$cur" ))
        ;;
        *)
            if __docker_compose_has_option "--stop|-s"; then
                __docker_compose_complete_services;
            else
                __docker_compose_complete_services --filter status=stopped;
            fi
        ;;
    esac
}
_docker_compose_run () 
{ 
    case "$prev" in 
        -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_compose_nospace;
            return
        ;;
        --entrypoint | --label | -l | --name | --user | -u | --volume | -v | --workdir | -w)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --entrypoint -e --help --label -l --name --no-deps --publish -p --rm --service-ports -T --use-aliases --user -u --volume -v --workdir -w" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_scale () 
{ 
    case "$prev" in 
        =)
            COMPREPLY=("$cur");
            return
        ;;
        --timeout | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --timeout -t" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($(compgen -S "=" -W "$(__docker_compose_services)" -- "$cur"));
            __docker_compose_nospace
        ;;
    esac
}
_docker_compose_start () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services --filter status=stopped
        ;;
    esac
}
_docker_compose_stop () 
{ 
    case "$prev" in 
        --timeout | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --timeout -t" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_running_services
        ;;
    esac
}
_docker_compose_top () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_running_services
        ;;
    esac
}
_docker_compose_unpause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services --filter status=paused
        ;;
    esac
}
_docker_compose_up () 
{ 
    case "$prev" in 
        =)
            COMPREPLY=("$cur");
            return
        ;;
        --exit-code-from)
            __docker_compose_complete_services;
            return
        ;;
        --scale)
            COMPREPLY=($(compgen -S "=" -W "$(__docker_compose_services)" -- "$cur"));
            __docker_compose_nospace;
            return
        ;;
        --timeout | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--abort-on-container-exit --always-recreate-deps --build -d --detach --exit-code-from --force-recreate --help --no-build --no-color --no-deps --no-recreate --no-start --renew-anon-volumes -V --remove-orphans --scale --timeout -t" -- "$cur" ))
        ;;
        *)
            __docker_compose_complete_services
        ;;
    esac
}
_docker_compose_version () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--short" -- "$cur" ))
        ;;
    esac
}
_docker_config () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_config_create () 
{ 
    case "$prev" in 
        --label | -l)
            return
        ;;
        --template-driver)
            COMPREPLY=($( compgen -W "golang" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --label -l --template-driver" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--label|-l|--template-driver');
            if [ "$cword" -eq "$((counter + 1))" ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_config_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_configs
        ;;
    esac
}
_docker_config_list () 
{ 
    _docker_config_ls
}
_docker_config_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_configs --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_configs --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_config_remove () 
{ 
    _docker_config_rm
}
_docker_config_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_configs
        ;;
    esac
}
_docker_container () 
{ 
    local subcommands="
		attach
		commit
		cp
		create
		diff
		exec
		export
		inspect
		kill
		logs
		ls
		pause
		port
		prune
		rename
		restart
		rm
		run
		start
		stats
		stop
		top
		unpause
		update
		wait
	";
    local aliases="
		list
		ps
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_container_attach () 
{ 
    __docker_complete_detach_keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach-keys --help --no-stdin --sig-proxy=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--detach-keys');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_commit () 
{ 
    case "$prev" in 
        --author | -a | --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--author -a --change -c --help --message -m --pause=false -p=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--author|-a|--change|-c|--message|-m');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_container_cp () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--archive -a --follow-link -L --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                case "$cur" in 
                    *:)
                        return
                    ;;
                    *)
                        _filedir;
                        local files=(${COMPREPLY[@]});
                        __docker_complete_containers_all;
                        COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                        local containers=(${COMPREPLY[@]});
                        COMPREPLY=($( compgen -W "${files[*]} ${containers[*]}" -- "$cur" ));
                        if [[ "${COMPREPLY[*]}" = *: ]]; then
                            __docker_nospace;
                        fi;
                        return
                    ;;
                esac;
            fi;
            (( counter++ ));
            if [ "$cword" -eq "$counter" ]; then
                if [ -e "$prev" ]; then
                    __docker_complete_containers_all;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace;
                else
                    _filedir;
                fi;
                return;
            fi
        ;;
    esac
}
_docker_container_create () 
{ 
    _docker_container_run_and_create
}
_docker_container_diff () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_exec () 
{ 
    __docker_complete_detach_keys && return;
    case "$prev" in 
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --workdir | -w)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --detach-keys --env -e --help --interactive -i --privileged -t --tty -u --user --workdir -w" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_export () 
{ 
    case "$prev" in 
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_inspect () 
{ 
    _docker_inspect --type container
}
_docker_container_kill () 
{ 
    case "$prev" in 
        --signal | -s)
            __docker_complete_signals;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --signal -s" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_list () 
{ 
    _docker_container_ls
}
_docker_container_logs () 
{ 
    case "$prev" in 
        --since | --tail | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --since --tail --timestamps -t --until" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail|--until');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        ancestor)
            __docker_complete_images --cur "${cur##*=}" --repo --tag --id;
            return
        ;;
        before)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        expose | publish)
            return
        ;;
        id)
            __docker_complete_containers_all --cur "${cur##*=}" --id;
            return
        ;;
        health)
            COMPREPLY=($( compgen -W "healthy starting none unhealthy" -- "${cur##*=}" ));
            return
        ;;
        is-task)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_containers_all --cur "${cur##*=}" --name;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        since)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        status)
            COMPREPLY=($( compgen -W "created dead exited paused restarting running removing" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "ancestor before exited expose health id is-task label name network publish since status volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | --last | -n)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --filter -f --format --help --last -n --latest -l --no-trunc --quiet -q --size -s" -- "$cur" ))
        ;;
    esac
}
_docker_container_pause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_port () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_container_ps () 
{ 
    _docker_container_ls
}
_docker_container_rename () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_restart () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --link -l --volumes -v" -- "$cur" ))
        ;;
        *)
            for arg in "${COMP_WORDS[@]}";
            do
                case "$arg" in 
                    --force | -f)
                        __docker_complete_containers_all;
                        return
                    ;;
                esac;
            done;
            __docker_complete_containers_removable
        ;;
    esac
}
_docker_container_run () 
{ 
    _docker_container_run_and_create
}
_docker_container_run_and_create () 
{ 
    local options_with_args="
		--add-host
		--attach -a
		--blkio-weight
		--blkio-weight-device
		--cap-add
		--cap-drop
		--cgroup-parent
		--cidfile
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpuset-cpus
		--cpus
		--cpuset-mems
		--cpu-shares -c
		--device
		--device-cgroup-rule
		--device-read-bps
		--device-read-iops
		--device-write-bps
		--device-write-iops
		--dns
		--dns-option
		--dns-search
		--entrypoint
		--env -e
		--env-file
		--expose
		--group-add
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname -h
		--ip
		--ip6
		--ipc
		--kernel-memory
		--label-file
		--label -l
		--link
		--link-local-ip
		--log-driver
		--log-opt
		--mac-address
		--memory -m
		--memory-swap
		--memory-swappiness
		--memory-reservation
		--mount
		--name
		--network
		--network-alias
		--oom-score-adj
		--pid
		--pids-limit
		--publish -p
		--restart
		--runtime
		--security-opt
		--shm-size
		--stop-signal
		--stop-timeout
		--storage-opt
		--tmpfs
		--sysctl
		--ulimit
		--user -u
		--userns
		--uts
		--volume-driver
		--volumes-from
		--volume -v
		--workdir -w
	";
    __docker_daemon_os_is windows && options_with_args+="
		--cpu-count
		--cpu-percent
		--io-maxbandwidth
		--io-maxiops
		--isolation
	";
    __docker_daemon_is_experimental && options_with_args+="
		--platform
	";
    local boolean_options="
		--disable-content-trust=false
		--help
		--init
		--interactive -i
		--no-healthcheck
		--oom-kill-disable
		--privileged
		--publish-all -P
		--read-only
		--tty -t
	";
    if [ "$command" = "run" ] || [ "$subcommand" = "run" ]; then
        options_with_args="$options_with_args
			--detach-keys
		";
        boolean_options="$boolean_options
			--detach -d
			--rm
			--sig-proxy=false
		";
        __docker_complete_detach_keys && return;
    fi;
    local all_options="$options_with_args $boolean_options";
    __docker_complete_log_driver_options && return;
    __docker_complete_restart && return;
    local key=$(__docker_map_key_of_current_option '--security-opt');
    case "$key" in 
        label)
            [[ $cur == *: ]] && return;
            COMPREPLY=($( compgen -W "user: role: type: level: disable" -- "${cur##*=}"));
            if [ "${COMPREPLY[*]}" != "disable" ]; then
                __docker_nospace;
            fi;
            return
        ;;
        seccomp)
            local cur=${cur##*=};
            _filedir;
            COMPREPLY+=($( compgen -W "unconfined" -- "$cur" ));
            return
        ;;
    esac;
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --attach | -a)
            COMPREPLY=($( compgen -W 'stdin stdout stderr' -- "$cur" ));
            return
        ;;
        --cap-add)
            __docker_complete_capabilities_addable;
            return
        ;;
        --cap-drop)
            __docker_complete_capabilities_droppable;
            return
        ;;
        --cidfile | --env-file | --label-file)
            _filedir;
            return
        ;;
        --device | --tmpfs | --volume | -v)
            case "$cur" in 
                *:*)

                ;;
                '')
                    COMPREPLY=($( compgen -W '/' -- "$cur" ));
                    __docker_nospace
                ;;
                /*)
                    _filedir;
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --ipc)
            case "$cur" in 
                *:*)
                    cur="${cur#*:}";
                    __docker_complete_containers_running
                ;;
                *)
                    COMPREPLY=($( compgen -W 'none host private shareable container:' -- "$cur" ));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --isolation)
            if __docker_daemon_os_is windows; then
                __docker_complete_isolation;
                return;
            fi
        ;;
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network)
            case "$cur" in 
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --pid)
            case "$cur" in 
                *:*)
                    __docker_complete_containers_running --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W 'host container:' -- "$cur" ));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --runtime)
            __docker_complete_runtimes;
            return
        ;;
        --security-opt)
            COMPREPLY=($( compgen -W "apparmor= label= no-new-privileges seccomp=" -- "$cur"));
            if [ "${COMPREPLY[*]}" != "no-new-privileges" ]; then
                __docker_nospace;
            fi;
            return
        ;;
        --stop-signal)
            __docker_complete_signals;
            return
        ;;
        --storage-opt)
            COMPREPLY=($( compgen -W "size" -S = -- "$cur"));
            __docker_nospace;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --userns)
            COMPREPLY=($( compgen -W "host" -- "$cur" ));
            return
        ;;
        --volume-driver)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --volumes-from)
            __docker_complete_containers_all;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag --id;
            fi
        ;;
    esac
}
_docker_container_start () 
{ 
    __docker_complete_detach_keys && return;
    case "$prev" in 
        --checkpoint)
            if __docker_daemon_is_experimental; then
                return;
            fi
        ;;
        --checkpoint-dir)
            if __docker_daemon_is_experimental; then
                _filedir -d;
                return;
            fi
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--attach -a --detach-keys --help --interactive -i";
            __docker_daemon_is_experimental && options+=" --checkpoint --checkpoint-dir";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_container_stats () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --format --help --no-stream --no-trunc" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_stop () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_top () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_unpause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_unpauseable;
            fi
        ;;
    esac
}
_docker_container_update () 
{ 
    local options_with_args="
		--blkio-weight
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpus
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--kernel-memory
		--memory -m
		--memory-reservation
		--memory-swap
		--restart
	";
    local boolean_options="
		--help
	";
    local all_options="$options_with_args $boolean_options";
    __docker_complete_restart && return;
    case "$prev" in 
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_wait () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_cp () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        case "$cur" in 
            *:)
                return
            ;;
            *)
                __docker_containers_all;
                COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                compopt -o nospace;
                return
            ;;
        esac;
    fi;
    (( counter++ ));
    if [ $cword -eq $counter ]; then
        _filedir;
        return;
    fi
}
_docker_create () 
{ 
    _docker_container_create
}
_docker_daemon () 
{ 
    local boolean_options="
		$global_boolean_options
		--experimental
		--help
		--icc=false
		--init
		--ip-forward=false
		--ip-masq=false
		--iptables=false
		--ipv6
		--live-restore
		--no-new-privileges
		--raw-logs
		--selinux-enabled
		--userland-proxy=false
		--version -v
	";
    local options_with_args="
		$global_options_with_args
		--add-runtime
		--allow-nondistributable-artifacts
		--api-cors-header
		--authorization-plugin
		--bip
		--bridge -b
		--cgroup-parent
		--cluster-advertise
		--cluster-store
		--cluster-store-opt
		--config-file
		--containerd
		--cpu-rt-period
		--cpu-rt-runtime
		--data-root
		--default-address-pool
		--default-gateway
		--default-gateway-v6
		--default-runtime
		--default-shm-size
		--default-ulimit
		--dns
		--dns-search
		--dns-opt
		--exec-opt
		--exec-root
		--fixed-cidr
		--fixed-cidr-v6
		--group -G
		--init-path
		--insecure-registry
		--ip
		--label
		--log-driver
		--log-opt
		--max-concurrent-downloads
		--max-concurrent-uploads
		--metrics-addr
		--mtu
		--network-control-plane-mtu
		--node-generic-resource
		--oom-score-adjust
		--pidfile -p
		--registry-mirror
		--seccomp-profile
		--shutdown-timeout
		--storage-driver -s
		--storage-opt
		--swarm-default-advertise-addr
		--userland-proxy-path
		--userns-remap
	";
    __docker_complete_log_driver_options && return;
    key=$(__docker_map_key_of_current_option '--cluster-store-opt');
    case "$key" in 
        kv.*file)
            cur=${cur##*=};
            _filedir;
            return
        ;;
    esac;
    local key=$(__docker_map_key_of_current_option '--storage-opt');
    case "$key" in 
        dm.blkdiscard | dm.override_udev_sync_check | dm.use_deferred_removal | dm.use_deferred_deletion)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        dm.directlvm_device | dm.thinpooldev)
            cur=${cur##*=};
            _filedir;
            return
        ;;
        dm.fs)
            COMPREPLY=($( compgen -W "ext4 xfs" -- "${cur##*=}" ));
            return
        ;;
        dm.libdm_log_level)
            COMPREPLY=($( compgen -W "2 3 4 5 6 7" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --authorization-plugin)
            __docker_complete_plugins_bundled --type Authorization;
            return
        ;;
        --cluster-store)
            COMPREPLY=($( compgen -W "consul etcd zk" -S "://" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cluster-store-opt)
            COMPREPLY=($( compgen -W "discovery.heartbeat discovery.ttl kv.cacertfile kv.certfile kv.keyfile kv.path" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --config-file | --containerd | --init-path | --pidfile | -p | --tlscacert | --tlscert | --tlskey | --userland-proxy-path)
            _filedir;
            return
        ;;
        --exec-root | --data-root)
            _filedir -d;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --storage-driver | -s)
            COMPREPLY=($( compgen -W "aufs btrfs devicemapper overlay overlay2 vfs zfs" -- "$(echo "$cur" | tr '[:upper:]' '[:lower:]')" ));
            return
        ;;
        --storage-opt)
            local btrfs_options="btrfs.min_space";
            local devicemapper_options="
				dm.basesize
				dm.blkdiscard
				dm.blocksize
				dm.directlvm_device
				dm.fs
				dm.libdm_log_level
				dm.loopdatasize
				dm.loopmetadatasize
				dm.min_free_space
				dm.mkfsarg
				dm.mountopt
				dm.override_udev_sync_check
				dm.thinpooldev
				dm.thinp_autoextend_percent
				dm.thinp_autoextend_threshold
				dm.thinp_metapercent
				dm.thinp_percent
				dm.use_deferred_deletion
				dm.use_deferred_removal
			";
            local overlay2_options="overlay2.size";
            local zfs_options="zfs.fsname";
            local all_options="$btrfs_options $devicemapper_options $overlay2_options $zfs_options";
            case $(__docker_value_of_option '--storage-driver|-s') in 
                '')
                    COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
                ;;
                btrfs)
                    COMPREPLY=($( compgen -W "$btrfs_options" -S = -- "$cur" ))
                ;;
                devicemapper)
                    COMPREPLY=($( compgen -W "$devicemapper_options" -S = -- "$cur" ))
                ;;
                overlay2)
                    COMPREPLY=($( compgen -W "$overlay2_options" -S = -- "$cur" ))
                ;;
                zfs)
                    COMPREPLY=($( compgen -W "$zfs_options" -S = -- "$cur" ))
                ;;
                *)
                    return
                ;;
            esac;
            __docker_nospace;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --metrics-addr)
            __docker_complete_local_ips;
            __docker_append_to_completions ":";
            __docker_nospace;
            return
        ;;
        --seccomp-profile)
            _filedir json;
            return
        ;;
        --swarm-default-advertise-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --userns-remap)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
    esac
}
_docker_deploy () 
{ 
    __docker_daemon_is_experimental && _docker_stack_deploy
}
_docker_diff () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        __docker_containers_all;
    fi
}
_docker_docker () 
{ 
    case "$prev" in 
        -H)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-H" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$commands help" -- "$cur" ))
        ;;
    esac
}
_docker_events () 
{ 
    case "$prev" in 
        --since)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--since" -- "$cur" ))
        ;;
        *)

        ;;
    esac
}
_docker_exec () 
{ 
    _docker_container_exec
}
_docker_export () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        __docker_containers_all;
    fi
}
_docker_help () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        COMPREPLY=($( compgen -W "$commands" -- "$cur" ));
    fi
}
_docker_history () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-q --quiet --no-trunc" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_image_repos_and_tags_and_ids;
            fi
        ;;
    esac
}
_docker_image () 
{ 
    local subcommands="
		build
		history
		import
		inspect
		load
		ls
		prune
		pull
		push
		rm
		save
		tag
	";
    local aliases="
		images
		list
		remove
		rmi
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_image_build () 
{ 
    local options_with_args="
		--add-host
		--build-arg
		--cache-from
		--cgroup-parent
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--cpu-period
		--cpu-quota
		--file -f
		--iidfile
		--label
		--memory -m
		--memory-swap
		--network
		--shm-size
		--tag -t
		--target
		--ulimit
	";
    __docker_daemon_os_is windows && options_with_args+="
		--isolation
	";
    local boolean_options="
		--compress
		--disable-content-trust=false
		--force-rm
		--help
		--no-cache
		--pull
		--quiet -q
		--rm
	";
    if __docker_daemon_is_experimental; then
        options_with_args+="
			--platform
		";
        boolean_options+="
			--squash
			--stream
		";
    fi;
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --build-arg)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cache-from)
            __docker_complete_images --repo --tag --id;
            return
        ;;
        --file | -f | --iidfile)
            _filedir;
            return
        ;;
        --isolation)
            if __docker_daemon_os_is windows; then
                __docker_complete_isolation;
                return;
            fi
        ;;
        --network)
            case "$cur" in 
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --tag | -t)
            __docker_complete_images --repo --tag;
            return
        ;;
        --target)
            local context_pos=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            local context="${words[$context_pos]}";
            context="${context:-.}";
            local file="$( __docker_value_of_option '--file|f' )";
            local default_file="${context%/}/Dockerfile";
            local dockerfile="${file:-$default_file}";
            local targets="$( sed -n 's/^FROM .\+ AS \(.\+\)/\1/p' "$dockerfile" 2>/dev/null )";
            COMPREPLY=($( compgen -W "$targets" -- "$cur" ));
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                _filedir -d;
            fi
        ;;
    esac
}
_docker_image_history () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --help --human=false -H=false --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--format');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_image_images () 
{ 
    _docker_image_ls
}
_docker_image_import () 
{ 
    case "$prev" in 
        --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--change -c --help --message -m" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--change|-c|--message|-m');
            if [ "$cword" -eq "$counter" ]; then
                _filedir;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_image_inspect () 
{ 
    _docker_inspect --type image
}
_docker_image_list () 
{ 
    _docker_image_ls
}
_docker_image_load () 
{ 
    case "$prev" in 
        --input | -i | "<")
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --input -i --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_image_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        before | since)
            __docker_complete_images --cur "${cur##*=}" --force-tag --id;
            return
        ;;
        dangling)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        label)
            return
        ;;
        reference)
            __docker_complete_images --cur "${cur##*=}" --repo --tag;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "before dangling label reference since" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        =)
            return
        ;;
        *)
            __docker_complete_images --repo --tag
        ;;
    esac
}
_docker_image_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_image_pull () 
{ 
    case "$prev" in 
        --platform)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--all-tags -a --disable-content-trust=false --help";
            __docker_daemon_is_experimental && options+=" --platform";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag --platform);
            if [ "$cword" -eq "$counter" ]; then
                for arg in "${COMP_WORDS[@]}";
                do
                    case "$arg" in 
                        --all-tags | -a)
                            __docker_complete_images --repo;
                            return
                        ;;
                    esac;
                done;
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_image_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust=false --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_image_remove () 
{ 
    _docker_image_rm
}
_docker_image_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --no-prune" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --force-tag --id
        ;;
    esac
}
_docker_image_rmi () 
{ 
    _docker_image_rm
}
_docker_image_save () 
{ 
    case "$prev" in 
        --output | -o | ">")
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --repo --tag --id
        ;;
    esac
}
_docker_image_tag () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_images () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-q --quiet -a --all --no-trunc -v --viz -t --tree" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_image_repos;
            fi
        ;;
    esac
}
_docker_import () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        return;
    fi;
    (( counter++ ));
    if [ $cword -eq $counter ]; then
        __docker_image_repos_and_tags;
        return;
    fi
}
_docker_info () 
{ 
    return
}
_docker_insert () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        __docker_image_repos_and_tags_and_ids;
    fi
}
_docker_inspect () 
{ 
    case "$prev" in 
        -f | --format)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-f --format" -- "$cur" ))
        ;;
        *)
            __docker_containers_and_images
        ;;
    esac
}
_docker_kill () 
{ 
    __docker_containers_running
}
_docker_load () 
{ 
    return
}
_docker_login () 
{ 
    case "$prev" in 
        -u | --username | -p | --password | -e | --email)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-u --username -p --password -e --email" -- "$cur" ))
        ;;
        *)

        ;;
    esac
}
_docker_logout () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_logs () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-f --follow" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_containers_all;
            fi
        ;;
    esac
}
_docker_network () 
{ 
    local subcommands="
		connect
		create
		disconnect
		inspect
		ls
		prune
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_network_connect () 
{ 
    local options_with_args="
		--alias
		--ip
		--ip6
		--link
		--link-local-ip
	";
    local boolean_options="
		--help
	";
    case "$prev" in 
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_networks;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_containers_all;
                fi;
            fi
        ;;
    esac
}
_docker_network_create () 
{ 
    case "$prev" in 
        --aux-address | --gateway | --ip-range | --ipam-opt | --ipv6 | --opt | -o | --subnet)
            return
        ;;
        --config-from)
            __docker_complete_networks;
            return
        ;;
        --driver | -d)
            __docker_complete_plugins_bundled --type Network --remove host --remove null --add macvlan;
            return
        ;;
        --ipam-driver)
            COMPREPLY=($( compgen -W "default" -- "$cur" ));
            return
        ;;
        --label)
            return
        ;;
        --scope)
            COMPREPLY=($( compgen -W "local swarm" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--attachable --aux-address --config-from --config-only --driver -d --gateway --help --ingress --internal --ip-range --ipam-driver --ipam-opt --ipv6 --label --opt -o --scope --subnet" -- "$cur" ))
        ;;
    esac
}
_docker_network_disconnect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_networks;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_containers_in_network "$prev";
                fi;
            fi
        ;;
    esac
}
_docker_network_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --verbose" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_network_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Network --add macvlan;
            return
        ;;
        id)
            __docker_complete_networks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_networks --cur "${cur##*=}" --name;
            return
        ;;
        scope)
            COMPREPLY=($( compgen -W "global local swarm" -- "${cur##*=}" ));
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "builtin custom" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "driver id label name scope type" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_network_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_network_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks --filter type=custom
        ;;
    esac
}
_docker_node () 
{ 
    local subcommands="
		demote
		inspect
		ls
		promote
		rm
		ps
		update
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_node_demote () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=manager
        ;;
    esac
}
_docker_node_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --add self
        ;;
    esac
}
_docker_node_list () 
{ 
    _docker_node_ls
}
_docker_node_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_nodes --cur "${cur##*=}" --id;
            return
        ;;
        membership)
            COMPREPLY=($( compgen -W "accepted pending" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_nodes --cur "${cur##*=}" --name;
            return
        ;;
        role)
            COMPREPLY=($( compgen -W "manager worker" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "id label membership name role" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_node_promote () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=worker
        ;;
    esac
}
_docker_node_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id label name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --add self
        ;;
    esac
}
_docker_node_remove () 
{ 
    _docker_node_rm
}
_docker_node_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes
        ;;
    esac
}
_docker_node_update () 
{ 
    case "$prev" in 
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --role)
            COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            return
        ;;
        --label-add | --label-rm)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--availability --help --label-add --label-rm --role" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--availability|--label-add|--label-rm|--role');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_nodes;
            fi
        ;;
    esac
}
_docker_pause () 
{ 
    _docker_container_pause
}
_docker_plugin () 
{ 
    local subcommands="
		create
		disable
		enable
		inspect
		install
		ls
		push
		rm
		set
		upgrade
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_create () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--compress --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    _filedir -d;
                fi;
            fi
        ;;
    esac
}
_docker_plugin_disable () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed --filter enabled=true;
            fi
        ;;
    esac
}
_docker_plugin_enable () 
{ 
    case "$prev" in 
        --timeout)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --timeout" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--timeout');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed --filter enabled=false;
            fi
        ;;
    esac
}
_docker_plugin_inspect () 
{ 
    case "$prev" in 
        --format | f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_install () 
{ 
    case "$prev" in 
        --alias)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--alias --disable --disable-content-trust=false --grant-all-permissions --help" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_list () 
{ 
    _docker_plugin_ls
}
_docker_plugin_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        capability)
            COMPREPLY=($( compgen -W "authz ipamdriver logdriver metricscollector networkdriver volumedriver" -- "${cur##*=}" ));
            return
        ;;
        enabled)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "capability enabled" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_remove () 
{ 
    _docker_plugin_rm
}
_docker_plugin_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_set () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_upgrade () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust --grant-all-permissions --help --skip-remote-check" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
                __ltrim_colon_completions "$cur";
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    local plugin_images="$(__docker_plugins_installed)";
                    COMPREPLY=($(compgen -S : -W "${plugin_images%:*}" -- "$cur"));
                    __docker_nospace;
                fi;
            fi
        ;;
    esac
}
_docker_port () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        __docker_containers_all;
    fi
}
_docker_ps () 
{ 
    case "$prev" in 
        --since-id | --before-id)
            COMPREPLY=($( compgen -W "$( __docker_q ps -a -q )" -- "$cur" ));
            return
        ;;
        -n)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-q --quiet -s --size -a --all --no-trunc -l --latest --since-id --before-id -n" -- "$cur" ))
        ;;
        *)

        ;;
    esac
}
_docker_pull () 
{ 
    case "$prev" in 
        -t | --tag)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-t --tag" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '-t|--tag');
            if [ $cword -eq $counter ]; then
                __docker_image_repos_and_tags;
            fi
        ;;
    esac
}
_docker_push () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        __docker_image_repos;
    fi
}
_docker_rename () 
{ 
    _docker_container_rename
}
_docker_restart () 
{ 
    case "$prev" in 
        -t | --time)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-t --time" -- "$cur" ))
        ;;
        *)
            __docker_containers_all
        ;;
    esac
}
_docker_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-v --volumes -l --link" -- "$cur" ))
        ;;
        *)
            __docker_containers_stopped
        ;;
    esac
}
_docker_rmi () 
{ 
    __docker_image_repos_and_tags_and_ids
}
_docker_run () 
{ 
    case "$prev" in 
        --cidfile)
            _filedir
        ;;
        --volumes-from)
            __docker_containers_all
        ;;
        -v | --volume)
            return
        ;;
        -e | --env)
            COMPREPLY=($( compgen -e -- "$cur" ));
            return
        ;;
        --entrypoint | -h | --hostname | -m | --memory | -u | --user | -w | --workdir | -c | --cpu-shares | -n | --name | -a | --attach | --link | -p | --publish | --expose | --dns | --lxc-conf)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--rm -d --detach -n --networking --privileged -P --publish-all -i --interactive -t --tty --cidfile --entrypoint -h --hostname -m --memory -u --user -w --workdir -c --cpu-shares --sig-proxy --name -a --attach -v --volume --link -e --env -p --publish --expose --dns --volumes-from --lxc-conf" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--cidfile|--volumes-from|-v|--volume|-e|--env|--entrypoint|-h|--hostname|-m|--memory|-u|--user|-w|--workdir|-c|--cpu-shares|-n|--name|-a|--attach|--link|-p|--publish|--expose|--dns|--lxc-conf');
            if [ $cword -eq $counter ]; then
                __docker_image_repos_and_tags_and_ids;
            fi
        ;;
    esac
}
_docker_save () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        __docker_image_repos_and_tags_and_ids;
    fi
}
_docker_search () 
{ 
    case "$prev" in 
        -s | --stars)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--no-trunc -t --trusted -s --stars" -- "$cur" ))
        ;;
        *)

        ;;
    esac
}
_docker_secret () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_secret_create () 
{ 
    case "$prev" in 
        --driver | -d | --label | -l)
            return
        ;;
        --template-driver)
            COMPREPLY=($( compgen -W "golang" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label -l --template-driver" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--driver|-d|--label|-l|--template-driver');
            if [ "$cword" -eq "$((counter + 1))" ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_secret_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_secret_list () 
{ 
    _docker_secret_ls
}
_docker_secret_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_secrets --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_secrets --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_secret_remove () 
{ 
    _docker_secret_rm
}
_docker_secret_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_service () 
{ 
    local subcommands="
		create
		inspect
		logs
		ls
		rm
		rollback
		scale
		ps
		update
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_service_create () 
{ 
    _docker_service_update_and_create
}
_docker_service_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_list () 
{ 
    _docker_service_ls
}
_docker_service_logs () 
{ 
    case "$prev" in 
        --since | --tail)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --no-resolve --no-task-ids --no-trunc --raw --since --tail --timestamps -t" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_services_and_tasks;
            fi
        ;;
    esac
}
_docker_service_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        mode)
            COMPREPLY=($( compgen -W "global replicated" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "id label mode name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_service_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
        node)
            __docker_complete_nodes --cur "${cur##*=}" --add self;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id name node" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_remove () 
{ 
    _docker_service_rm
}
_docker_service_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_rollback () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --help --quit -q" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_services;
            fi
        ;;
    esac
}
_docker_service_scale () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services;
            __docker_append_to_completions "=";
            __docker_nospace
        ;;
    esac
}
_docker_service_update () 
{ 
    _docker_service_update_and_create
}
_docker_service_update_and_create () 
{ 
    local options_with_args="
		--endpoint-mode
		--entrypoint
		--force
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname
		--isolation
		--limit-cpu
		--limit-memory
		--log-driver
		--log-opt
		--replicas
		--reserve-cpu
		--reserve-memory
		--restart-condition
		--restart-delay
		--restart-max-attempts
		--restart-window
		--rollback-delay
		--rollback-failure-action
		--rollback-max-failure-ratio
		--rollback-monitor
		--rollback-order
		--rollback-parallelism
		--stop-grace-period
		--stop-signal
		--update-delay
		--update-failure-action
		--update-max-failure-ratio
		--update-monitor
		--update-order
		--update-parallelism
		--user -u
		--workdir -w
	";
    __docker_daemon_os_is windows && options_with_args+="
		--credential-spec
	";
    local boolean_options="
		--detach -d
		--help
		--init
		--no-healthcheck
		--read-only
		--tty -t
		--with-registry-auth
	";
    __docker_complete_log_driver_options && return;
    if [ "$subcommand" = "create" ]; then
        options_with_args="$options_with_args
			--config
			--constraint
			--container-label
			--dns
			--dns-option
			--dns-search
			--env -e
			--env-file
			--generic-resource
			--group
			--host
			--label -l
			--mode
			--mount
			--name
			--network
			--placement-pref
			--publish -p
			--secret
		";
        case "$prev" in 
            --env-file)
                _filedir;
                return
            ;;
            --mode)
                COMPREPLY=($( compgen -W "global replicated" -- "$cur" ));
                return
            ;;
        esac;
    fi;
    if [ "$subcommand" = "update" ]; then
        options_with_args="$options_with_args
			--args
			--config-add
			--config-rm
			--constraint-add
			--constraint-rm
			--container-label-add
			--container-label-rm
			--dns-add
			--dns-option-add
			--dns-option-rm
			--dns-rm
			--dns-search-add
			--dns-search-rm
			--env-add
			--env-rm
			--generic-resource-add
			--generic-resource-rm
			--group-add
			--group-rm
			--host-add
			--host-rm
			--image
			--label-add
			--label-rm
			--mount-add
			--mount-rm
			--network-add
			--network-rm
			--placement-pref-add
			--placement-pref-rm
			--publish-add
			--publish-rm
			--rollback
			--secret-add
			--secret-rm
		";
        case "$prev" in 
            --env-rm)
                COMPREPLY=($( compgen -e -- "$cur" ));
                return
            ;;
            --image)
                __docker_complete_images --repo --tag --id;
                return
            ;;
        esac;
    fi;
    local strategy=$(__docker_map_key_of_current_option '--placement-pref|--placement-pref-add|--placement-pref-rm');
    case "$strategy" in 
        spread)
            COMPREPLY=($( compgen -W "engine.labels node.labels" -S . -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$prev" in 
        --config | --config-add | --config-rm)
            __docker_complete_configs;
            return
        ;;
        --endpoint-mode)
            COMPREPLY=($( compgen -W "dnsrr vip" -- "$cur" ));
            return
        ;;
        --env | -e | --env-add)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --group | --group-add | --group-rm)
            COMPREPLY=($(compgen -g -- "$cur"));
            return
        ;;
        --host | --host-add | --host-rm)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network | --network-add | --network-rm)
            __docker_complete_networks;
            return
        ;;
        --placement-pref | --placement-pref-add | --placement-pref-rm)
            COMPREPLY=($( compgen -W "spread" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --restart-condition)
            COMPREPLY=($( compgen -W "any none on-failure" -- "$cur" ));
            return
        ;;
        --rollback-failure-action)
            COMPREPLY=($( compgen -W "continue pause" -- "$cur" ));
            return
        ;;
        --secret | --secret-add | --secret-rm)
            __docker_complete_secrets;
            return
        ;;
        --stop-signal)
            __docker_complete_signals;
            return
        ;;
        --update-failure-action)
            COMPREPLY=($( compgen -W "continue pause rollback" -- "$cur" ));
            return
        ;;
        --update-order | --rollback-order)
            COMPREPLY=($( compgen -W "start-first stop-first" -- "$cur" ));
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$subcommand" = "update" ]; then
                if [ "$cword" -eq "$counter" ]; then
                    __docker_complete_services;
                fi;
            else
                if [ "$cword" -eq "$counter" ]; then
                    __docker_complete_images --repo --tag --id;
                fi;
            fi
        ;;
    esac
}
_docker_stack () 
{ 
    local subcommands="
		deploy
		ls
		ps
		rm
		services
	";
    local aliases="
		down
		list
		remove
		up
	";
    __docker_complete_stack_orchestrator_options && return;
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            local options="--help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_stack_deploy () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --bundle-file)
            _filedir dab;
            return
        ;;
        --compose-file | -c)
            _filedir yml;
            return
        ;;
        --resolve-image)
            COMPREPLY=($( compgen -W "always changed never" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--compose-file -c --help --orchestrator";
            __docker_daemon_is_experimental && __docker_stack_orchestrator_is swarm && options+=" --bundle-file";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            __docker_stack_orchestrator_is swarm && options+=" --prune --resolve-image --with-registry-auth";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--bundle-file|--compose-file|-c|--kubeconfig|--namespace|--orchestrator|--resolve-image');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_down () 
{ 
    _docker_stack_rm
}
_docker_stack_list () 
{ 
    _docker_stack_ls
}
_docker_stack_ls () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--format --help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --all-namespaces --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
    esac
}
_docker_stack_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        id)
            __docker_complete_stacks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_stacks --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id name desired-state" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--filter -f --format --help --no-resolve --no-trunc --orchestrator --quiet -q";
            __docker_stack_orchestrator_is kubernetes && options+=" --all-namespaces --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--all-namespaces|--filter|-f|--format|--kubeconfig|--namespace');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_remove () 
{ 
    _docker_stack_rm
}
_docker_stack_rm () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$cur" in 
        -*)
            local options="--help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            __docker_complete_stacks
        ;;
    esac
}
_docker_stack_services () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        label)
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--filter -f --format --help --orchestrator --quiet -q";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--filter|-f|--format|--kubeconfig|--namespace|--orchestrator');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_up () 
{ 
    _docker_stack_deploy
}
_docker_start () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-a --attach -i --interactive" -- "$cur" ))
        ;;
        *)
            __docker_containers_stopped
        ;;
    esac
}
_docker_stats () 
{ 
    _docker_container_stats
}
_docker_stop () 
{ 
    case "$prev" in 
        -t | --time)
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-t --time" -- "$cur" ))
        ;;
        *)
            __docker_containers_running
        ;;
    esac
}
_docker_swarm () 
{ 
    local subcommands="
		ca
		init
		join
		join-token
		leave
		unlock
		unlock-key
		update
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_ca () 
{ 
    case "$prev" in 
        --ca-cert | --ca-key)
            _filedir;
            return
        ;;
        --cert-expiry | --external-ca)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--ca-cert --ca-key --cert-expiry --detach -d --external-ca --help --quiet -q --rotate" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_init () 
{ 
    case "$prev" in 
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --cert-expiry | --dispatcher-heartbeat | --external-ca | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
        --data-path-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --autolock --availability --cert-expiry --data-path-addr --dispatcher-heartbeat --external-ca --force-new-cluster --help --listen-addr --max-snapshots --snapshot-interval --task-history-limit" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_join () 
{ 
    case "$prev" in 
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --data-path-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
        --token)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --availability --data-path-addr --help --listen-addr --token" -- "$cur" ))
        ;;
        *:)
            COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ))
        ;;
    esac
}
_docker_swarm_join_token () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_swarm_leave () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_unlock () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_unlock_key () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_update () 
{ 
    case "$prev" in 
        --cert-expiry | --dispatcher-heartbeat | --external-ca | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--autolock --cert-expiry --dispatcher-heartbeat --external-ca --help --max-snapshots --snapshot-interval --task-history-limit" -- "$cur" ))
        ;;
    esac
}
_docker_system () 
{ 
    local subcommands="
		df
		events
		info
		prune
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_system_df () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --help --verbose -v" -- "$cur" ))
        ;;
    esac
}
_docker_system_events () 
{ 
    local key=$(__docker_map_key_of_current_option '-f|--filter');
    case "$key" in 
        container)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        daemon)
            local name=$(__docker_q info | sed -n 's/^\(ID\|Name\): //p');
            COMPREPLY=($( compgen -W "$name" -- "${cur##*=}" ));
            return
        ;;
        event)
            COMPREPLY=($( compgen -W "
				attach
				commit
				connect
				copy
				create
				delete
				destroy
				detach
				die
				disable
				disconnect
				enable
				exec_create
				exec_detach
				exec_die
				exec_start
				export
				health_status
				import
				install
				kill
				load
				mount
				oom
				pause
				pull
				push
				reload
				remove
				rename
				resize
				restart
				save
				start
				stop
				tag
				top
				unmount
				unpause
				untag
				update
			" -- "${cur##*=}" ));
            return
        ;;
        image)
            __docker_complete_images --cur "${cur##*=}" --repo --tag;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        scope)
            COMPREPLY=($( compgen -W "local swarm" -- "${cur##*=}" ));
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "config container daemon image network plugin secret service volume" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "container daemon event image label network scope type volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --since | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --since --until --format" -- "$cur" ))
        ;;
    esac
}
_docker_system_info () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_system_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --filter --help --volumes" -- "$cur" ))
        ;;
    esac
}
_docker_tag () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "-f --force" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ $cword -eq $counter ]; then
                __docker_image_repos_and_tags;
                return;
            fi;
            (( counter++ ));
            if [ $cword -eq $counter ]; then
                __docker_image_repos_and_tags;
                return;
            fi
        ;;
    esac
}
_docker_top () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ $cword -eq $counter ]; then
        __docker_containers_running;
    fi
}
_docker_trust () 
{ 
    local subcommands="
		inspect
		revoke
		sign
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_trust_inspect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --pretty" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_trust_revoke () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --yes -y" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_trust_sign () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --local" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_unpause () 
{ 
    _docker_container_unpause
}
_docker_update () 
{ 
    _docker_container_update
}
_docker_version () 
{ 
    return
}
_docker_volume () 
{ 
    local subcommands="
		create
		inspect
		ls
		prune
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_volume_create () 
{ 
    case "$prev" in 
        --driver | -d)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --label | --opt | -o)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label --opt -o" -- "$cur" ))
        ;;
    esac
}
_docker_volume_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_volume_list () 
{ 
    _docker_volume_ls
}
_docker_volume_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        dangling)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Volume;
            return
        ;;
        name)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling driver label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_volume_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label!" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter --force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_volume_remove () 
{ 
    _docker_volume_rm
}
_docker_volume_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_wait () 
{ 
    __docker_containers_all
}
_dvd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur 2> /dev/null;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 ]] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted x tmp;
    _quote_readline_by_ref "$cur" quoted;
    x=$( compgen -d -- "$quoted" ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.@($1|${1^^})"};
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
            toks+=("$tmp");
        done <<< "$x";
    fi;
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && "$1" != -d && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return 0;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [[ -d /etc/fs ]] && command ls /etc/fs )";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
}
_gem191 () 
{ 
    local cur prev completions;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    COMMANDS='build cert check cleanup contents dependency\
      environment fetch generate_index help install list\
      lock mirror outdated pristine query rdoc search server\
      sources specification uninstall unpack update which';
    GEM_OPTIONS='\
      -h --help\
      -v --version';
    COMMON_OPTIONS='\
      -h --help\
      -V --verbose --no-verbose\
      -q --quiet\
      --config-file\
      --backtrace\
      --debug';
    CERT_OPTIONS='\
      -a -add\
      -l --list\
      -r --remove\
      -b --build\
      -C --certificate\
      -K --private-key\
      -s --sign';
    CHECK_OPTIONS='\
      --verify\
      -a --alien\
      -t --test\
      -v --version';
    CLEANUP_OPTIONS='\
      -d --dry-run';
    CONTENTS_OPTIONS='\
      -v --version\
      -s --spec-dir\
      -l --lib-only --no-lib-only';
    DEPENDENCY_OPTIONS='\
      -v --version\
      --platform\
      -R --reverse-dependencies --no-reverse-dependencies\
      -p --pipe';
    ENVIRONMENT_OPTIONS='';
    FETCH_OPTIONS='\
      -v --version\
      --platform\
      -B --bulk-threshold\
      -p --http-proxy --no-http-proxy\
      --source';
    GENERATE_INDEX_OPTIONS='\
      -d --directory';
    HELP_OPTIONS=$COMMANDS;
    INSTALL_OPTIONS='\
      --platform\
      -v --version\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LIST_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LOCK_OPTIONS='\
      -s --strict --no-strict';
    MIRROR_OPTIONS='';
    OUTDATED_OPTIONS='\
      --platform';
    PRISTINE_OPTIONS='\
      --all\
      -v --version';
    QUERY_OPTIONS='\
      -n --name-matches\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    RDOC_OPTIONS='\
      --all\
      --rdoc --no-rdoc\
      --ri --no-ri\
      -v --version';
    SEARCH_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    SERVER_OPTIONS='\
      -p --port\
      -d --dir\
      --daemon --no-daemon';
    SOURCES_OPTIONS='\
      -a --add\
      -l --list\
      -r --remove\
      -u --update\
      -c --clear-all';
    SPECIFICATION_OPTIONS='\
      -v --version\
      --platform\
      --all\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    UNINSTALL_OPTIONS='\
      -a --all --no-all\
      -i --ignore-dependencies --no-ignore-dependencies\
      -x --executables --no-executables\
      -v --version\
      --platform';
    UNPACK_OPTIONS='\
      --target\
      -v --version';
    UPDATE_OPTIONS='\
      --system\
      --platform\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    WHICH_OPTIONS='\
      -a --all --no-all\
      -g --gems-first --no-gems-first';
    case "${prev}" in 
        build)
            completions="$COMMON_OPTIONS $BUILD_OPTIONS"
        ;;
        cert)
            completions="$COMMON_OPTIONS $CERT_OPTIONS"
        ;;
        check)
            completions="$COMMON_OPTIONS $CHECK_OPTIONS"
        ;;
        cleanup)
            completions="$COMMON_OPTIONS $CLEANUP_OPTIONS"
        ;;
        contents)
            completions="$COMMON_OPTIONS $CONTENTS_OPTIONS"
        ;;
        dependency)
            completions="$COMMON_OPTIONS $DEPENDENCY_OPTIONS"
        ;;
        environment)
            completions="$COMMON_OPTIONS $ENVIRONMENT_OPTIONS"
        ;;
        fetch)
            completions="$COMMON_OPTIONS $FETCH_OPTIONS"
        ;;
        generate_index)
            completions="$COMMON_OPTIONS $GENERATE_INDEX_OPTIONS"
        ;;
        help)
            completions="$COMMON_OPTIONS $HELP_OPTIONS"
        ;;
        install)
            completions="$COMMON_OPTIONS $INSTALL_OPTIONS"
        ;;
        list)
            completions="$COMMON_OPTIONS $LIST_OPTIONS"
        ;;
        lock)
            completions="$COMMON_OPTIONS $LOCK_OPTIONS"
        ;;
        mirror)
            completions="$COMMON_OPTIONS $MIRROR_OPTIONS"
        ;;
        outdated)
            completions="$COMMON_OPTIONS $OUTDATED_OPTIONS"
        ;;
        pristine)
            completions="$COMMON_OPTIONS $PRISTINE_OPTIONS"
        ;;
        query)
            completions="$COMMON_OPTIONS $QUERY_OPTIONS"
        ;;
        rdoc)
            completions="$COMMON_OPTIONS $RDOC_OPTIONS"
        ;;
        search)
            completions="$COMMON_OPTIONS $SEARCH_OPTIONS"
        ;;
        server)
            completions="$COMMON_OPTIONS $SERVER_OPTIONS"
        ;;
        sources)
            completions="$COMMON_OPTIONS $SOURCES_OPTIONS"
        ;;
        specification)
            completions="$COMMON_OPTIONS $SPECIFICATION_OPTIONS"
        ;;
        uninstall)
            completions="$COMMON_OPTIONS $UNINSTALL_OPTIONS"
        ;;
        unpack)
            completions="$COMMON_OPTIONS $UNPACK_OPTIONS"
        ;;
        update)
            completions="$COMMON_OPTIONS $UPDATE_OPTIONS"
        ;;
        which)
            completions="$COMMON_OPTIONS $WHICH_OPTIONS"
        ;;
        *)
            completions="$COMMANDS $GEM_OPTIONS"
        ;;
    esac;
    COMPREPLY=($( compgen -W "$completions" -- $cur ));
    return 0
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_grub_editenv () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        create | list | set | unset)
            COMPREPLY=("");
            return
        ;;
    esac;
    __grubcomp "$(__grub_get_options_from_help)
                create list set unset"
}
_grub_install () 
{ 
    local cur prev last split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
        --disk-module)
            __grubcomp "biosdisk ata";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_mkconfig () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkfont () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkimage () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory | -p | --prefix)
            _filedir -d;
            return
        ;;
        -O | --format)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F ":" '/available formats/ { print $2 }' |                         sed 's/, / /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkpasswd_pbkdf2 () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkrescue () 
{ 
    local cur prev last;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_probe () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -t | --target)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F "[()]" '/--target=/ { print $2 }' |                         sed 's/|/ /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_script_check () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_set_entry () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        __grub_list_menuentries;
    fi
}
_grub_setup () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_init_completion () 
{ 
    local exclude= flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
        else
            i=$(( ++i ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_ip_addresses () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
            sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'                 -ne 's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    if [[ ${#config[@]} -gt 0 ]]; then
        local OIFS=$IFS IFS='
' j;
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [[ -z $awkcur ]]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [[ ${#kh[@]} -gt 0 ]]; then
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {
            sub("^@[^ ]+ +", ""); \
            sub(" .*$", ""); \
            for (i=1; i<=NF; ++i) { \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_loexp_ () 
{ 
    local c=${COMP_WORDS[COMP_CWORD]};
    local a="${COMP_LINE}";
    local e s g=0 cd dc t="";
    local IFS;
    shopt -q extglob && g=1;
    test $g -eq 0 && shopt -s extglob;
    cd='*-?(c)d*';
    dc='*-d?(c)*';
    case "${1##*/}" in 
        lomath)
            e='!*.+(sxm|SXM|smf|SMF|mml|MML|odf|ODF)'
        ;;
        lofromtemplate)
            e='!*.+(stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX)'
        ;;
        loimpress)
            e='!*.+(sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX)'
        ;;
        loffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lobase)
            e='!*.+(odb|ODB)'
        ;;
        libreoffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lowriter)
            e='!*.+(doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxg|SXG|odm|ODM|sgl|SGL)'
        ;;
        loweb)
            e='!*.+(htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        unopkg)
            e='!*.+(oxt|OXT)'
        ;;
        localc)
            e='!*.+(sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX)'
        ;;
        lodraw)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG)'
        ;;
        *)
            e='!*'
        ;;
    esac;
    case "$(complete -p ${1##*/} 2> /dev/null)" in 
        *-d*)

        ;;
        *)
            s="-S/"
        ;;
    esac;
    IFS='
';
    case "$c" in 
        \$\(*\))
            eval COMPREPLY=\(${c}\)
        ;;
        \$\(*)
            COMPREPLY=($(compgen -c -P '$(' -S ')'  -- ${c#??}))
        ;;
        \`*\`)
            eval COMPREPLY=\(${c}\)
        ;;
        \`*)
            COMPREPLY=($(compgen -c -P '\`' -S '\`' -- ${c#?}))
        ;;
        \$\{*\})
            eval COMPREPLY=\(${c}\)
        ;;
        \$\{*)
            COMPREPLY=($(compgen -v -P '${' -S '}'  -- ${c#??}))
        ;;
        \$*)
            COMPREPLY=($(compgen -v -P '$'          -- ${c#?}))
        ;;
        \~*/*)
            COMPREPLY=($(compgen -f -X "$e"         -- ${c}))
        ;;
        \~*)
            COMPREPLY=($(compgen -u ${s}	 	-- ${c}))
        ;;
        *@*)
            COMPREPLY=($(compgen -A hostname -P '@' -S ':' -- ${c#*@}))
        ;;
        *[*?[]*)
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *[?*+\!@]\(*\)*)
            if test $g -eq 0; then
                COMPREPLY=($(compgen -f -X "$e" -- $c));
                test $g -eq 0 && shopt -u extglob;
                return;
            fi;
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *)
            if test "$c" = ".."; then
                COMPREPLY=($(compgen -d -X "$e" -S / ${_nosp} -- $c));
            else
                for s in $(compgen -f -X "$e" -- $c);
                do
                    if test -d $s; then
                        COMPREPLY=(${COMPREPLY[@]} $(compgen -f -X "$e" -S / -- $s));
                    else
                        if test -z "$t"; then
                            COMPREPLY=(${COMPREPLY[@]} $s);
                        else
                            case "$(file -b $s 2> /dev/null)" in 
                                $t)
                                    COMPREPLY=(${COMPREPLY[@]} $s)
                                ;;
                            esac;
                        fi;
                    fi;
                done;
            fi
        ;;
    esac;
    test $g -eq 0 && shopt -u extglob
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return 0
        ;;
        --*dir*)
            _filedir -d;
            return 0
        ;;
        --*file* | --*path*)
            _filedir;
            return 0
        ;;
        --+([-a-z0-9_]))
            local argtype=$( $1 --help 2>&1 | sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return 0
                ;;
                *file* | *path*)
                    _filedir;
                    return 0
                ;;
            esac
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY+=($( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$( getconf $var 2>/dev/null );
    printf %s ${n:-1}
}
_pacat () 
{ 
    local cur prev comps;
    local flags='-h --help --version -r --record -p --playback -v --verbose -s
                --server= -d --device= -n --client-name= --stream-name= --volume=
                --rate= --format= --channels= --channel-map= --fix-format --fix-rate
                --fix-channels --no-remix --no-remap --latency= --process-time=
                --latency-msec= --process-time-msec= --property= --raw --passthrough
                --file-format= --list-file-formats';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        --device=*)
            cur=${cur#*=};
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --rate=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '32000 44100 48000 9600 192000' -- "$cur"))
        ;;
        --file-format=*)
            cur=${cur#*=};
            comps=$(_pacat_file_formats);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            _filedir
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
        -d)
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_pacat_file_formats () 
{ 
    while IFS='	' read name _; do
        printf "%s\n" "$name";
    done < <(pacat --list-file-formats 2> /dev/null)
}
_pacmd () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version';
    local commands=(exit help list-modules list-sinks list-sources list-clients list-samples list-sink-inputs list-source-outputs stat info load-module unload-module describe-module set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mut set-sink-input-mute set-source-output-mute update-sink-proplist update-source-proplist update-sink-input-proplist update-source-output-proplist set-default-sink set-default-source kill-client kill-sink-input kill-source-output play-sample remove-sample load-sample load-sample-lazy load-sample-dir-lazy play-file dump move-sink-input move-source-output suspend-sink suspend-source suspend set-card-profile set-sink-port set-source-port set-port-latency-offset set-log-target set-log-level set-log-meta set-log-time set-log-backtrace);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        play-sample | play-file)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample*)
            _filedir
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*port*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
    esac;
    case $prev in 
        list-*)

        ;;
        describe-module | load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample-dir-lazy)
            _filedir -d
        ;;
        play-file)
            _filedir
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port-*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-log-target)
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        set-log-level)
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        set-log-meta | set-log-time | suspend)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
        suspend)
            COMPREPLY=($(compgen -W 'suspend suspend-sink suspend-source' -- "$cur"))
        ;;
        load-sample)
            COMPREPLY=($(compgen -W 'load-sample load-sample-lazy load-sample-dir-lazy' -- "$cur"))
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_pactl () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version -s --server= --client-name=';
    local list_types='short sinks sources sink-inputs source outputs cards
                    modules samples clients';
    local commands=(stat info list exit upload-sample play-sample remove-sample load-module unload-module move-sink-input move-source-output suspend-sink suspend-source set-card-profile set-sink-port set-source-port set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mute set-sink-input-mute set-source-output-mute set-sink-formats set-port-latency-offset subscribe help);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        list)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        play-sample)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-port)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false toggle' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
        set-port-*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --server)
            compopt +o nospace;
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $prev in 
        list)
            COMPREPLY=($(compgen -W '${list_types[*]}' -- "$cur"))
        ;;
        stat)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        upload-sample)
            _filedir
        ;;
        play-sample)

        ;;
        remove-sample)

        ;;
        load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-sink-formats)
            comps=$(__sinks_idx);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        -s)
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_padsp () 
{ 
    local cur prev;
    local flags='-h -s -n -m -M -S -D -d';
    _get_comp_words_by_ref cur prev;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_parse_help () 
{ 
    eval local cmd=$( quote "$1" );
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([ '	'])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$( quote "$1" );
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pasuspender () 
{ 
    local cur prev;
    local flags='-h --help --version -s --server=';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_pci_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_poff () 
{ 
    local prev cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '-r -d -c -a -h -v' -- $cur));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pon () 
{ 
    local cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pulseaudio () 
{ 
    local cur prev words cword;
    local flags='-h --help --version --dump-conf --dump-resample-methods --cleanup-shm
                --start -k --kill --check --system= -D --daemonize= --fail= --high-priority=
                --realtime= --disallow-module-loading= --disallow-exit= --exit-idle-time=
                --scache-idle-time= --log-level= -v --log-target= --log-meta= --log-time=
                --log-backtrace= -p --dl-search-path= --resample-method= --use-pit-file=
                --no-cpu-limit= --disable-shm= -L --load= -F --file= -C -n';
    _init_completion -n = || return;
    case $cur in 
        --system=* | --daemonize=* | --fail=* | --high-priority=* | --realtime=* | --disallow-*=* | --log-meta=* | --log-time=* | --use-pid-file=* | --no-cpu-limit=* | --disable-shm=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        --log-target=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        --log-level=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        --dl-search-path=*)
            cur=${cur#*=};
            _filedir -d
        ;;
        --file=*)
            cur=${cur#*=};
            _filedir
        ;;
        --resample-method=*)
            cur=${cur#*=};
            comps=$(__resample_methods);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --load=*)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -D)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        -p)
            _filedir -d
        ;;
        -F)
            _filedir
        ;;
        -L)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == ~* ]]; then
                printf -v $2 ~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_redis-cli () 
{ 
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    opts='bgrewriteaof bgsave dbsize debug decr decrby del echo exists expire expireat flushall flushdb get getset incr incrby info keys lastsave lindex llen lpop lpush lrange lrem lset ltrim mget move mset msetnx ping randomkey rename renamenx rewriteaof rpop rpoplpush rpush sadd save scard sdiff sdiffstore select set setnx shutdown sinter sinterstore sismember slaveof smembers smove sort spop srandmember srem sunion sunionstore ttl type zadd zcard zincrby zrange zrangebyscore zrem zremrangebyscore zrevrange zscore';
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
        return 0;
    fi
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return 0;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($( compgen -W '`sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local restore_nullglob=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions) ));
    $restore_nullglob;
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_svn () 
{ 
    local cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='add blame annotate praise cat changelist cl checkout co cleanup';
    cmds="$cmds commit ci copy cp delete remove rm diff export help import";
    cmds="$cmds info list ls lock log merge mergeinfo mkdir move mv rename";
    cmds="$cmds patch propdel pdel propedit pedit propget pget proplist";
    cmds="$cmds plist propset pset relocate resolve resolved revert status";
    cmds="$cmds  switch unlock update upgrade";
    local helpOpts='--help -h';
    local specOpts="--version $helpOpts";
    optsParam="-r|--revision|--username|--password|--targets";
    optsParam="$optsParam|-x|--extensions|-m|--message|-F|--file";
    optsParam="$optsParam|--encoding|--diff-cmd|--diff3-cmd|--editor-cmd";
    optsParam="$optsParam|--old|--new|--config-dir|--config-option";
    optsParam="$optsParam|--native-eol|-l|--limit|-c|--change";
    optsParam="$optsParam|--depth|--set-depth|--with-revprop";
    optsParam="$optsParam|--cl|--changelist|--accept|--show-revs";
    local svnProps revProps allProps psCmds propCmds;
    svnProps="svn:keywords svn:executable svn:needs-lock svn:externals
	          svn:ignore svn:eol-style svn:mime-type $SVN_BASH_FILE_PROPS";
    revProps="svn:author svn:log svn:date $SVN_BASH_REV_PROPS";
    allProps=($svnProps $revProps);
    psCmds='propset|pset|ps';
    propCmds="$psCmds|propget|pget|pg|propedit|pedit|pe|propdel|pdel|pd";
    local urlSchemas='file:/// http:// https:// svn:// svn+ssh://';
    local cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0;
    local prev= help= prop= val= isRevProp= last='none' nargs=0 stat=;
    local options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=;
    local acceptOpt= URL= hasReintegrateOpt=;
    for opt in "${COMP_WORDS[@]}";
    do
        [[ -n $isCur ]] && stat=$last;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        let i++;
        [ $last = 'none' ] && { 
            last='first';
            continue
        };
        if [[ $prev == @($optsParam) ]]; then
            [[ $prev = '--accept' ]] && acceptOpt=$opt;
            prev='';
            last='skip';
            continue;
        fi;
        if [[ $prev == @(<|>|>>|[12]>|[12]>>) ]]; then
            prev='';
            last='skip';
            continue;
        fi;
        prev=$opt;
        if [[ ! -n $cmd && -n $opt && ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]; then
            cmd=$opt;
            [[ $cmd == @($propCmds) ]] && isPropCmd=1;
            [[ $cmd == @($psCmds) ]] && isPsCmd=1;
            [[ $cmd == @(${helpOpts// /|}) ]] && cmd='help';
            [[ $cmd = 'help' ]] && isHelpCmd=1;
            if [[ -n $isHelpCmd && -n $cmd && $cmd != 'help' && ! -n $help ]]; then
                help=$cmd;
                cmd='help';
            fi;
            last='cmd';
            continue;
        fi;
        if [[ -n $isHelpCmd && ! -n $help && -n $opt && $opt != -* ]]; then
            help=$opt;
            last='help';
            continue;
        fi;
        if [[ -n $isPropCmd && ! -n $prop && -n $opt && $opt != -* ]]; then
            prop=$opt;
            [[ $prop == @(${revProps// /|}) ]] && isRevProp=1;
            last='prop';
            continue;
        fi;
        if [[ -n $isPsCmd && -n $prop && ! -n $val && $opt != -* ]]; then
            val=$opt;
            last='val';
            continue;
        fi;
        if [[ $last != 'onlyarg' ]]; then
            case $opt in 
                -r | --revision | --revision=*)
                    hasRevisionOpt=1
                ;;
                --revprop)
                    hasRevPropOpt=1;
                    allProps=($revProps);
                    nExpectArgs=1
                ;;
                -h | --help)
                    isHelpCmd=1
                ;;
                -F | --file)
                    val='-F'
                ;;
                --relocate)
                    hasRelocateOpt=1
                ;;
                --reintegrate)
                    hasReintegrateOpt=1
                ;;
            esac;
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='onlyarg';
                continue;
            fi;
            if [[ $opt == -* ]]; then
                [[ ! -n $isCur ]] && options="$options $opt ";
                last='opt';
                continue;
            fi;
        else
            let nargs++;
            continue;
        fi;
        if [[ $cmd = 'merge' && ! -n $URL ]]; then
            URL=$opt;
        fi;
        last='arg';
        let nargs++;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ ! -n $cmd || $stat = 'cmd' ]]; then
        COMPREPLY=($( compgen -W "$cmds $specOpts" -- $cur ));
        return 0;
    fi;
    if [[ $stat = 'help' || ( -n $isHelpCmd && ! -n $help ) ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    if [[ $cmd == @(co|checkout|ls|list) && $stat = 'arg' && $SVN_BASH_COMPL_EXT == *urls* ]]; then
        if [[ $cur == file:* ]]; then
            local where=${cur/file:/};
            COMPREPLY=($(compgen -d -S '/' -X '*/.*' -- $where ));
            return;
        else
            if [[ $cur == *:* ]]; then
                local urls= file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        local url=$(_svn_read_hashfile svn:realmstring < $file);
                        url=${url/*</};
                        url=${url/>*/};
                        urls="$urls $url";
                    fi;
                done;
                local prefix=${cur%:*} suffix=${cur#*:} c= choices=;
                for c in $urls;
                do
                    [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
                done;
                COMPREPLY=($(compgen -W "$choices" -- $suffix ));
                return;
            else
                COMPREPLY=($(compgen -W "$urlSchemas" -- $cur));
                return;
            fi;
        fi;
    fi;
    if [[ $cmd = 'merge' || $cmd = 'mergeinfo' ]]; then
        local here=$(_svn_info URL);
        if [[ ! -n $URL && $stat = 'arg' ]]; then
            if [[ "$here" == */branches/* ]]; then
                COMPREPLY=($(compgen -W ${here/\/branches\/*/\/trunk} -- $cur ));
                return 0;
            else
                if [[ "$here" == */trunk* ]]; then
                    COMPREPLY=($(compgen -W ${here/\/trunk*/\/branches\/} -- $cur ));
                    return 0;
                else
                    COMPREPLY=($(compgen -W $(_svn_info Root) -- $cur ));
                    return 0;
                fi;
            fi;
        else
            if [[ $URL == */branches/* && $here == */trunk* && ! -n $hasReintegrateOpt && $cur = '' && $stat = 'arg' ]]; then
                COMPREPLY=($(compgen -W '--reintegrate' -- $cur ));
                return 0;
            fi;
        fi;
    fi;
    if [[ $stat = 'skip' ]]; then
        local previous=${COMP_WORDS[COMP_CWORD-1]};
        local values= dirs= beep= exes=;
        [[ $previous = '--config-dir' ]] && dirs=1;
        [[ $previous = --*-cmd ]] && exes=1;
        [[ $previous = '--native-eol' ]] && values='LF CR CRLF';
        [[ $previous = '--limit' ]] && values='0 1 2 3 4 5 6 7 8 9';
        [[ $previous = '--revision' || $previous = '-r' ]] && values='HEAD BASE PREV COMMITTED 0 {';
        [[ $previous = '--encoding' ]] && values="latin1 utf8 $SVN_BASH_ENCODINGS";
        [[ $previous = '--extensions' || $previous = '-x' ]] && values="--unified --ignore-space-change 		   --ignore-all-space --ignore-eol-style --show-c-functions";
        [[ $previous = '--depth' ]] && values='empty files immediates infinity';
        [[ $previous = '--set-depth' ]] && values='empty exclude files immediates infinity';
        [[ $previous = '--accept' ]] && { 
            if [[ $cmd = 'resolve' ]]; then
                values='base working mine-full theirs-full';
            else
                values="postpone base mine-full theirs-full edit launch 			mine-conflict theirs-conflict";
            fi
        };
        [[ $previous = '--show-revs' ]] && values='merged eligible';
        if [[ $previous = '--username' ]]; then
            values="$SVN_BASH_USERNAME";
            if [[ $SVN_BASH_COMPL_EXT == *username* ]]; then
                local file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        values="$values $(_svn_read_hashfile username < $file)";
                    fi;
                done;
            fi;
            [[ ! -n "$values" ]] && beep=1;
        fi;
        [[ $previous = '--password' ]] && beep=1;
        [[ -n $values ]] && COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n $dirs ]] && COMPREPLY=($( compgen -o dirnames -- $cur ));
        [[ -n $exes ]] && COMPREPLY=($( compgen -c -- $cur ));
        [[ -n $beep ]] && { 
            echo -en "\a";
            COMPREPLY=('')
        };
        return 0;
    fi;
    if [[ -n $isPropCmd && ( ! -n $prop || $stat = 'prop' ) && $cur != -* ]]; then
        local choices=;
        if [[ $cur == *:* ]]; then
            local prefix=${cur%:*} suffix=${cur#*:} c=;
            for c in ${allProps[@]};
            do
                [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
            done;
            cur=$suffix;
        else
            COMPREPLY=($( compgen -W "${allProps[*]}" -- $cur ));
            [ ${#COMPREPLY[@]} -eq 1 ] && return 0;
            local seen= n=0 last= c=;
            for c in ${allProps[@]%:*};
            do
                if [[ $c == $cur* && ( ! -n $seen || $c != @($seen) ) ]]; then
                    let n++;
                    last=$c;
                    choices="$choices $c:";
                    if [[ -n $seen ]]; then
                        seen="$seen|$c*";
                    else
                        seen="$c*";
                    fi;
                fi;
            done;
            [[ $n -eq 1 ]] && choices="$last:1 $last:2";
        fi;
        COMPREPLY=($( compgen -W "$choices" -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && ! -n $hasRevPropOpt ]]; then
        COMPREPLY=($( compgen -W '--revprop' -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && -n $hasRevPropOpt && ! -n $hasRevisionOpt ]]; then
        COMPREPLY=($( compgen -W '--revision' -- $cur ));
        return 0;
    fi;
    if [[ -n $isPsCmd && -n $prop && ( ! -n $val || $stat = 'val' ) ]]; then
        local values="\' --file";
        case $prop in 
            svn:keywords)
                values="Id Rev URL Date Author Header \' $SVN_BASH_KEYWORDS"
            ;;
            svn:executable | svn:needs-lock)
                values='\\*'
            ;;
            svn:eol-style)
                values='native LF CR CRLF'
            ;;
            svn:mime-type)
                values="text/ text/plain text/html text/xml text/rtf
                       image/ image/png image/gif image/jpeg image/tiff
                       audio/ audio/midi audio/mpeg
                       video/ video/mpeg video/mp4
                       application/ application/octet-stream
                       $SVN_BASH_MIME_TYPE"
            ;;
        esac;
        COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n ${COMPREPLY} ]] && return 0;
    fi;
    case $cmd in 
        merge)
            nExpectArgs=3
        ;;
        mergeinfo)
            nExpectArgs=1
        ;;
        copy | cp | move | mv | rename | ren | export | import)
            nExpectArgs=2
        ;;
        switch | sw)
            [[ ! -n $hasRelocateOpt ]] && nExpectArgs=2
        ;;
        help | h)
            nExpectArgs=0
        ;;
        --version)
            nExpectArgs=0
        ;;
    esac;
    if [[ -n $nExpectArgs && $nargs -gt $nExpectArgs ]]; then
        echo -en "\a";
        COMPREPLY=('');
        return 0;
    fi;
    if [[ $cur != -* || $stat = 'onlyarg' ]]; then
        if [[ $SVN_BASH_COMPL_EXT == *svnstatus* ]]; then
            local status='svn status --non-interactive';
            [[ $SVN_BASH_COMPL_EXT == *recurse* ]] || status="$status --non-recursive";
            [[ $SVN_BASH_COMPL_EXT == *externals* ]] || status="$status --ignore-externals";
            local cs= files=;
            [[ -n $cur ]] && cs=$cur*;
            case $cmd in 
                st*)
                    files=$cur*
                ;;
                ci | commit | revert | di*)
                    files=$($status $cs| _svn_grcut '@([MADR!]*| M*|_M*)')
                ;;
                add)
                    files=$($status $cs| _svn_grcut '\?*')
                ;;
                unlock)
                    files=$($status $cs| _svn_grcut '@(??L*|?????[KOTB]*)')
                ;;
                resolve*)
                    files=$($status $cs| _svn_grcut '@(?C*|C*)')
                ;;
                praise | blame | ann*)
                    files=$( _svn_lls all $cur* )
                ;;
                p*)
                    if [[ $cmd == @($propCmds) && $prop == @(svn:ignore|svn:externals) ]]; then
                        files=$( _svn_lls dir . $cur* );
                    else
                        files="$( _svn_lls all $cur* )
                                   $($status $cs | _svn_grcut 'A*' )";
                    fi
                ;;
                info)
                    files="$( _svn_lls all $cur* )
                               $($status $cs | _svn_grcut 'A*' )"
                ;;
                remove | rm | del* | move | mv | rename)
                    files=$( _svn_lls all $cur* )
                ;;
                mkdir)
                    files=$( _svn_lls dir $cur* )
                ;;
                log | lock | up* | cl* | switch)
                    files=$( _svn_lls all $cur* )
                ;;
                merge)
                    files=$( _svn_lls all $cur* )
                ;;
                ls | list)
                    files=$( _svn_lls all $cur* )
                ;;
                *)
                    local fallback=1
                ;;
            esac;
            if [[ $SVN_BASH_COMPL_EXT != *recurse* ]]; then
                files="$files $( _svn_lls dir $cur* )";
            fi;
            if [[ -n $files ]]; then
                COMPREPLY=($( compgen -W "$files" -- $cur ));
                [[ -n "${COMPREPLY[*]}" ]] || COMPREPLY=('');
            else
                if [[ ! -n $fallback ]]; then
                    echo -en "\a";
                    COMPREPLY=('');
                fi;
            fi;
        fi;
        return 0;
    fi;
    pOpts="--username --password --no-auth-cache --non-interactive 	       --trust-server-cert --force-interactive";
    mOpts="-m --message -F --file --encoding --force-log --with-revprop";
    rOpts="-r --revision";
    qOpts="-q --quiet";
    nOpts="-N --non-recursive --depth";
    gOpts="-g --use-merge-history";
    cOpts="--cl --changelist";
    cmdOpts=;
    case $cmd in 
        --version)
            cmdOpts="$qOpts"
        ;;
        add)
            cmdOpts="--auto-props --no-auto-props --force --targets 		         --no-ignore --parents $nOpts $qOpts $pOpts"
        ;;
        blame | annotate | ann | praise)
            cmdOpts="$rOpts $pOpts -v --verbose --incremental --xml 		         -x --extensions --force $gOpts"
        ;;
        cat)
            cmdOpts="$rOpts $pOpts"
        ;;
        changelist | cl)
            cmdOpts="--targets $pOpts $qOpts $cOpts                          -R --recursive --depth --remove"
        ;;
        checkout | co)
            cmdOpts="$rOpts $qOpts $nOpts $pOpts --ignore-externals                          --force"
        ;;
        cleanup)
            cmdOpts="--diff3-cmd $pOpts"
        ;;
        commit | ci)
            cmdOpts="$mOpts $qOpts $nOpts --targets --editor-cmd $pOpts 		         --no-unlock $cOpts --keep-changelists 		         --include-externals"
        ;;
        copy | cp)
            cmdOpts="$mOpts $rOpts $qOpts --editor-cmd $pOpts --parents 		         --ignore-externals"
        ;;
        delete | del | remove | rm)
            cmdOpts="--force $mOpts $qOpts --targets --editor-cmd $pOpts                          --keep-local"
        ;;
        diff | di)
            cmdOpts="$rOpts -x --extensions --diff-cmd --no-diff-deleted 		         $nOpts $pOpts --force --old --new --notice-ancestry 		         -c --change --summarize $cOpts --xml --git 		         --internal-diff --show-copies-as-adds 		         --ignore-properties --properties-only --no-diff-added 		         --patch-compatible"
        ;;
        export)
            cmdOpts="$rOpts $qOpts $pOpts $nOpts --force --native-eol                          --ignore-externals --ignore-keywords"
        ;;
        help | h | \?)
            cmdOpts=
        ;;
        import)
            cmdOpts="--auto-props --no-auto-props $mOpts $qOpts $nOpts 		         --no-ignore --editor-cmd $pOpts --force"
        ;;
        info)
            cmdOpts="$pOpts $rOpts --targets -R --recursive --depth                          --incremental --xml $cOpts"
        ;;
        list | ls)
            cmdOpts="$rOpts -v --verbose -R --recursive $pOpts                          --incremental --xml --depth --include-externals"
        ;;
        lock)
            cmdOpts="-m --message -F --file --encoding --force-log                          --targets --force $pOpts"
        ;;
        log)
            cmdOpts="$rOpts -v --verbose --targets $pOpts --stop-on-copy 		         --incremental --xml $qOpts -l --limit -c --change                          $gOpts --with-all-revprops --with-revprop --depth 		         --diff --diff-cmd -x --extensions --internal-diff 		         --with-no-revprops --search --search-and"
        ;;
        merge)
            cmdOpts="$rOpts $nOpts $qOpts --force --dry-run --diff3-cmd 		         $pOpts --ignore-ancestry -c --change -x --extensions                          --record-only --accept --reintegrate 		         --allow-mixed-revisions -v --verbose"
        ;;
        mergeinfo)
            cmdOpts="$rOpts $pOpts --depth --show-revs -R --recursive"
        ;;
        mkdir)
            cmdOpts="$mOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        move | mv | rename | ren)
            cmdOpts="$mOpts $rOpts $qOpts --force --editor-cmd $pOpts                          --parents --allow-mixed-revisions"
        ;;
        patch)
            cmdOpts="$qOpts $pOpts --dry-run --ignore-whitespace 			--reverse-diff --strip"
        ;;
        propdel | pdel | pd)
            cmdOpts="$qOpts -R --recursive $rOpts $pOpts $cOpts                          --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        propedit | pedit | pe)
            cmdOpts="--editor-cmd $pOpts $mOpts --force";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts"
        ;;
        propget | pget | pg)
            cmdOpts="-v --verbose -R --recursive $rOpts --strict 		         $pOpts $cOpts --depth --xml --show-inherited-props";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-v --verbose -R --recursive $rOpts --revprop $qOpts 		         $pOpts $cOpts --depth --xml --show-inherited-props"
        ;;
        propset | pset | ps)
            cmdOpts="$qOpts --targets -R --recursive 		         --encoding $pOpts --force $cOpts --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts";
            [[ -n $val ]] || cmdOpts="$cmdOpts -F --file"
        ;;
        relocate)
            cmdOpts="--ignore-externals $pOpts"
        ;;
        resolve)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --accept                          --depth"
        ;;
        resolved)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --depth"
        ;;
        revert)
            cmdOpts="--targets -R --recursive $qOpts $cOpts                          --depth $pOpts"
        ;;
        status | stat | st)
            cmdOpts="-u --show-updates -v --verbose $nOpts $qOpts $pOpts 		         --no-ignore --ignore-externals --incremental --xml                          $cOpts"
        ;;
        switch | sw)
            cmdOpts="--relocate $rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --force --accept --ignore-externals --set-depth 		         --ignore-ancestry"
        ;;
        unlock)
            cmdOpts="--targets --force $pOpts"
        ;;
        update | up)
            cmdOpts="$rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --ignore-externals --force --accept $cOpts                          --parents --editor-cmd --set-depth"
        ;;
        upgrade)
            cmdOpts="$qOpts $pOpts"
        ;;
        *)

        ;;
    esac;
    [[ "$cmd" != "--version" ]] && cmdOpts="$cmdOpts $helpOpts";
    cmdOpts="$cmdOpts --config-dir --config-option";
    if [[ $acceptOpt == @(edit|launch) ]]; then
        cmdOpts=${cmdOpts/ --non-interactive / };
    fi;
    for opt in $options;
    do
        local optBase;
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -R)
                cmdOpts=${cmdOpts/ --recursive / }
            ;;
            --recursive)
                cmdOpts=${cmdOpts/ -R / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --change / }
            ;;
            --change)
                cmdOpts=${cmdOpts/ -c / }
            ;;
            --auto-props)
                cmdOpts=${cmdOpts/ --no-auto-props / }
            ;;
            --no-auto-props)
                cmdOpts=${cmdOpts/ --auto-props / }
            ;;
            -g)
                cmdOpts=${cmdOpts/ --use-merge-history / }
            ;;
            --use-merge-history)
                cmdOpts=${cmdOpts/ -g / }
            ;;
            -m | --message | -F | --file)
                cmdOpts=${cmdOpts/ --message / };
                cmdOpts=${cmdOpts/ -m / };
                cmdOpts=${cmdOpts/ --file / };
                cmdOpts=${cmdOpts/ -F / }
            ;;
        esac;
        if [ $isHelpCmd ]; then
            cmdOpts=${cmdOpts/ -h / };
            cmdOpts=${cmdOpts/ --help / };
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svn_grcut () 
{ 
    local re=$1 line= old_IFS;
    old_IFS="$IFS";
    IFS='
';
    while read -r line; do
        [[ ! -n $re || $line == $re ]] && echo "${line/????????/}";
    done;
    IFS="$old_IFS"
}
_svn_info () 
{ 
    local what=$1 line=;
    LANG=C LC_MESSAGES=C svn info --non-interactive 2> /dev/null | while read line; do
        [[ $line == *"$what: "* ]] && echo ${line#*: };
    done
}
_svn_lls () 
{ 
    local opt=$1 f=;
    shift;
    for f in "$@";
    do
        if [[ $opt == @(dir|all) && -d "$f" ]]; then
            echo "$f/";
        else
            if [[ $opt == @(file|all) ]]; then
                local dn= fn="$f";
                [[ "$f" == */* ]] && dn=${f%\/*}/ fn=${f##*\/};
                [ -f "${dn}.svn/text-base/${fn}.svn-base" ] && echo "$f";
            fi;
        fi;
    done
}
_svn_read_hashfile () 
{ 
    local tkey=$1 key= val=;
    while true; do
        read tag len;
        [ $tag = 'END' ] && break;
        [ $tag != 'K' ] && { 
            return
        };
        read -r -n $len key;
        read;
        read tag len;
        [ $tag != 'V' ] && { 
            return
        };
        read -r -n $len val;
        read;
        if [[ $key = $tkey ]]; then
            echo "$val";
            return;
        fi;
    done
}
_svnadmin () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='crashtest create deltify dump freeze help hotcopy list-dblogs \
	      list-unused-dblogs load lock lslocks lstxns pack recover rmlocks \
	      rmtxns setlog setrevprop setuuid unlock upgrade verify --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|--parent-dir|--fs-type|-M|--memory-cache-size";
    optsParam="$optsParam|-F|--file";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        create)
            cmdOpts="--bdb-txn-nosync --bdb-log-keep --config-dir 		         --fs-type --pre-1.4-compatible --pre-1.5-compatible 		         --pre-1.6-compatible --compatible-version"
        ;;
        deltify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        dump)
            cmdOpts="-r --revision --incremental -q --quiet --deltas 		         -M --memory-cache-size"
        ;;
        freeze)
            cmdOpts="-F --file"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        hotcopy)
            cmdOpts="--clean-logs"
        ;;
        load)
            cmdOpts="--ignore-uuid --force-uuid --parent-dir -q --quiet 		         --use-pre-commit-hook --use-post-commit-hook 		         --bypass-prop-validation -M --memory-cache-size"
        ;;
        lock | unlock)
            cmdOpts="--bypass-hooks"
        ;;
        recover)
            cmdOpts="--wait"
        ;;
        rmtxns)
            cmdOpts="-q --quiet"
        ;;
        setlog)
            cmdOpts="-r --revision --bypass-hooks"
        ;;
        setrevprop)
            cmdOpts="-r --revision --use-pre-revprop-change-hook 		         --use-post-revprop-change-hook"
        ;;
        verify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -F)
                cmdOpts=${cmdOpts/ --file / }
            ;;
            --file)
                cmdOpts=${cmdOpts/ -F / }
            ;;
            -M)
                cmdOpts=${cmdOpts/ --memory-cache-size / }
            ;;
            --memory-cache-size)
                cmdOpts=${cmdOpts/ --M / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svndumpfilter () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='exclude help include --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--targets";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        exclude | include)
            cmdOpts="--drop-empty-revs --renumber-revs
		         --skip-missing-merge-sources --targets
		         --preserve-revprops --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnlook () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='author cat changed date diff dirs-changed help history info \
	      lock log propget proplist tree uuid youngest --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|-t|--transaction|-l|--limit|-x|--extensions";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        author)
            cmdOpts="-r --revision -t --transaction"
        ;;
        cat)
            cmdOpts="-r --revision -t --transaction"
        ;;
        changed)
            cmdOpts="-r --revision -t --transaction --copy-info"
        ;;
        date)
            cmdOpts="-r --revision -t --transaction"
        ;;
        diff)
            cmdOpts="-r --revision -t --transaction --diff-copy-from 		         --no-diff-added --no-diff-deleted -x --extensions"
        ;;
        dirs-changed)
            cmdOpts="-r --revision -t --transaction"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        history)
            cmdOpts="-r --revision -l --limit --show-ids"
        ;;
        info)
            cmdOpts="-r --revision -t --transaction"
        ;;
        lock)
            cmdOpts=
        ;;
        log)
            cmdOpts="-r --revision -t --transaction"
        ;;
        propget | pget | pg)
            cmdOpts="-r --revision -t --transaction --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-r --revision -t --transaction --revprop -v --verbose --xml"
        ;;
        tree)
            cmdOpts="-r --revision -t --transaction --full-paths -N --non-recursive --show-ids"
        ;;
        uuid)
            cmdOpts=
        ;;
        youngest)
            cmdOpts=
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -t)
                cmdOpts=${cmdOpts/ --transaction / }
            ;;
            --transaction)
                cmdOpts=${cmdOpts/ -t / }
            ;;
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnsync () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='copy-revprops help info initialize synchronize --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--config-dir|--config-option|--source-username|--source-password";
    optsParam="$optsParam|--sync-username|--sync-password";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        copy-revprops | initialize | init | synchronize | sync)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option -q --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        info)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnversion () 
{ 
    local cmdOpts=" -n --no-newline -c --committed -h --help --version ";
    local cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=();
    local options= wcpath= trailurl= last='none' stat= opt= i=-1 isCur=;
    for opt in ${COMP_WORDS[@]};
    do
        [[ $i -eq $COMP_CWORD ]] && stat=$last;
        let i++;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        if [ $last = 'none' ]; then
            last='first';
            continue;
        fi;
        if [[ $last != 'arg' && $opt == -* ]]; then
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='arg';
            else
                options="$options $opt ";
                last='opt';
            fi;
            continue;
        fi;
        if [[ $opt != -* ]]; then
            last='arg';
            if [[ ! -n $wcpath ]]; then
                wcpath=$opt;
            else
                if [[ ! -n $trailurl ]]; then
                    trailurl=$opt;
                fi;
            fi;
        fi;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ $cur != -* || $stat = 'arg' ]]; then
        [[ -n $wcpath && -n $trailurl ]] && COMPREPLY=('');
        return 0;
    fi;
    for opt in $options;
    do
        cmdOpts=${cmdOpts/ $opt / };
        case $opt in 
            -n)
                cmdOpts=${cmdOpts/ --no-newline / }
            ;;
            --no-newline)
                cmdOpts=${cmdOpts/ -n / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --committed / }
            ;;
            --committed)
                cmdOpts=${cmdOpts/ -c / }
            ;;
        esac;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
}
_terms () 
{ 
    COMPREPLY+=($( compgen -W         "$( sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_ufw () 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ufw_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                app)
                    COMPREPLY=($( compgen -W "$(_ufw_app_commands)" $cur ))
                ;;
                status)
                    COMPREPLY=($( compgen -W "$(_ufw_status_commands)" $cur ))
                ;;
                delete)
                    COMPREPLY=($( compgen -W "$(_ufw_rule_commands)" $cur ))
                ;;
                logging)
                    COMPREPLY=($( compgen -W "$(_ufw_logging_commands)" $cur ))
                ;;
                show)
                    COMPREPLY=($( compgen -W "$(_ufw_show_commands)" $cur ))
                ;;
                default)
                    COMPREPLY=($( compgen -W "$(_ufw_default_commands)" $cur ))
                ;;
            esac;
        fi;
    fi
}
_ufw_app_commands () 
{ 
    ufw --help | sed -e '1,/^Application profile commands:/d' -e '/^ [^ ]/!d' -e 's/[ \t]\+app[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g'
}
_ufw_commands () 
{ 
    commands=$(ufw --help | sed -e '1,/^Commands:/d' -e '/^Application profile commands:/Q' -e 's/^[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g' -e 's/|/ /g' | uniq);
    echo "$commands app"
}
_ufw_default_commands () 
{ 
    echo "allow deny reject"
}
_ufw_logging_commands () 
{ 
    echo "off on low medium high full"
}
_ufw_rule_commands () 
{ 
    echo "`_ufw_default_commands` limit"
}
_ufw_show_commands () 
{ 
    echo "raw"
}
_ufw_status_commands () 
{ 
    echo "numbered verbose"
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_update_initramfs () 
{ 
    local cur prev valid_options;
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == '-k' ]]; then
        _kernel_versions;
        COMPREPLY=($( compgen -W '${COMPREPLY[@]} all' -- "$cur" ));
        return;
    fi;
    valid_options=$( update-initramfs -h 2>&1 | 		sed -e '/^ -/!d;s/^ \(-\w\+\).*/\1/' );
    COMPREPLY=($( compgen -W "$valid_options" -- $cur ))
}
_upstart_events () 
{ 
    ( cd /etc/init && egrep --color=auto '^[[:space:]]*emits ' *.conf | cut -d: -f2- | sed 's/^[[:space:]]*emits //g' | tr ' ' '\n' | awk '{print $NF}' | grep --color=auto -v ^$ | sort -u )
}
_upstart_initctl () 
{ 
    _get_comp_words_by_ref cur prev;
    COMPREPLY=();
    case "$prev" in 
        start)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_startable_jobs)" -- ${cur}));
            return 0
        ;;
        stop)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        emit)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_events)" -- ${cur}));
            return 0
        ;;
        -i | --ignore-events)
            for cmd in check-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        -e | --enumerate)
            for cmd in show-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        reload | restart)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        status)
            COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        check-config)
            COMPREPLY=($(compgen -W "-w --warn -i --ignore-events= $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        show-config)
            COMPREPLY=($(compgen -W "-e --enumerate $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        -n | --no-wait)
            for cmd in start stop restart emit;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    case "$cmd" in 
                        start)
                            COMPREPLY=($(compgen -W "$(_upstart_startable_jobs)" -- ${cur}))
                        ;;
                        stop)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        restart)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        emit)
                            COMPREPLY=($(compgen -W "$(_upstart_events)" -- ${cur}))
                        ;;
                    esac;
                    return 0;
                fi;
            done
        ;;
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    cmds=$(initctl help|grep "^  [^ ]"|awk '{print $1}');
    COMPREPLY=($(compgen -W "${opts} ${cmds}" -- ${cur}))
}
_upstart_jobs () 
{ 
    initctl list | awk '{print $1}' | sort -u
}
_upstart_reload () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_restart () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_start () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_startable_jobs)" -- ${cur}));
    return 0
}
_upstart_startable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "stop/waiting" {print $1}'
}
_upstart_status () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q -d --detail -e --enumerate --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_jobs)" -- ${cur}));
    return 0
}
_upstart_stop () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_stoppable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "start/running" {print $1}'
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$( uname -s );
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_vagrant () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local command options;
    commands="box destroy halt init package plugin provision reload resume         ssh ssh-config status suspend up";
    if [[ $cword -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$commands -h --help -v --version" -- "$cur" ));
    else
        command=${words[1]};
        case $command in 
            box)
                _count_args;
                case $args in 
                    2)
                        options='add list remove repackage'
                    ;;
                    3)
                        subcommand=${words[2]};
                        case $subcommand in 
                            add)
                                options='-f --force --insecure --provider'
                            ;;
                        esac
                    ;;
                esac
            ;;
            destroy | halt)
                options='-f --force'
            ;;
            init | resume | status | suspend)
                options=''
            ;;
            package)
                options='--base --include --output --vagrantfile'
            ;;
            plugin)
                _count_args;
                case $args in 
                    2)
                        options='install license list uninstall'
                    ;;
                    3)
                        subcommand=${words[2]};
                        case $subcommand in 
                            install)
                                options='--entry-point --plugin-prerelease --plugin-source --plugin-version'
                            ;;
                        esac
                    ;;
                esac
            ;;
            provision)
                options='--provision-with'
            ;;
            reload)
                options='--no-provision --provision --provision-with'
            ;;
            ssh)
                options='-c --command -p --plain'
            ;;
            ssh-config)
                options='--host'
            ;;
            up)
                options='--no-provision --provision --provision-with --no-parallel --parallel --provider'
            ;;
        esac;
        COMPREPLY=($( compgen -W "$options -h --help" -- "$cur" ));
    fi;
    return 0
}
_variables () 
{ 
    if [[ $cur =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]]; then
        [[ $cur == *{* ]] && local suffix=} || local suffix=;
        COMPREPLY+=($( compgen -P ${BASH_REMATCH[1]} -S "$suffix" -v --             "${BASH_REMATCH[2]}" ));
        return 0;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        local compdir=./completions;
        [[ $BASH_SOURCE == */* ]] && compdir="${BASH_SOURCE%/*}/completions";
        . "$compdir/$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local restore_nullglob=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        $restore_nullglob;
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
    fi
}
_yum () 
{ 
    COMPREPLY=();
    local yum=$1 cur=$2 prev=$3 words=("${COMP_WORDS[@]}");
    declare -F _get_comp_words_by_ref &> /dev/null && _get_comp_words_by_ref -n = cur prev words;
    local cmds=(check check-update clean deplist distro-sync downgrade groupinfo groupinstall grouplist groupremove help history info install list makecache provides reinstall remove repolist resolvedep search shell update upgrade version);
    local i c cmd subcmd;
    for ((i=1; i < ${#words[@]}-1; i++ ))
    do
        [[ -n $cmd ]] && subcmd=${words[i]} && break;
        for c in ${cmds[@]} check-rpmdb distribution-synchronization erase groupupdate grouperase localinstall localupdate whatprovides;
        do
            [[ ${words[i]} == $c ]] && cmd=$c && break;
        done;
    done;
    case $cmd in 
        check | check-rpmdb)
            COMPREPLY=($( compgen -W 'dependencies duplicates all'                 -- "$cur" ));
            return 0
        ;;
        check-update | grouplist | makecache | provides | whatprovides | resolvedep | search)
            return 0
        ;;
        clean)
            [ "$prev" = "$cmd" ] && COMPREPLY=($( compgen -W 'expire-cache packages headers
                    metadata cache dbcache all' -- "$cur" ));
            return 0
        ;;
        deplist)
            COMPREPLY=($( compgen -f -o plusdirs -X '!*.[rs]pm' -- "$cur" ));
            _yum_list all "$cur";
            return 0
        ;;
        distro-sync | distribution-synchronization)
            [ "$prev" = "$cmd" ] && COMPREPLY=($( compgen -W 'full different' -- "$cur" ));
            _yum_list installed "$cur";
            return 0
        ;;
        downgrade | reinstall)
            _yum_binrpmfiles "$cur";
            _yum_list installed "$cur";
            return 0
        ;;
        erase | remove)
            _yum_list installed "$cur";
            return 0
        ;;
        group*)
            _yum_grouplist "" "$cur";
            return 0
        ;;
        help)
            [ "$prev" = "$cmd" ] && COMPREPLY=($( compgen -W '${cmds[@]}' -- "$cur" ));
            return 0
        ;;
        history)
            if [[ $prev == $cmd ]]; then
                COMPREPLY=($( compgen -W 'info list summary undo redo new
                    addon-info package-list rollback' -- "$cur" ));
                return 0;
            fi;
            case $subcmd in 
                undo | redo | repeat | addon | addon-info | rollback)
                    _yum_transactions;
                    COMPREPLY=($( compgen -W "${COMPREPLY[@]} last"                         -- "$cur" ))
                ;;
                package-list | pkg | pkgs | pkg-list | pkgs-list | package | packages | packages-list)
                    _yum_list available "$cur"
                ;;
                info | list | summary)
                    _yum_transactions;
                    if [[ $subcmd != info ]]; then
                        COMPREPLY=($( compgen -W "${COMPREPLY[@]} all"                             -- "$cur" ));
                        [[ $cur != all ]] && _yum_list available "$cur";
                    else
                        _yum_list available "$cur";
                    fi
                ;;
            esac;
            return 0
        ;;
        info)
            _yum_list all "$cur";
            return 0
        ;;
        install)
            _yum_binrpmfiles "$cur";
            _yum_list available "$cur";
            return 0
        ;;
        list)
            [ "$prev" = "$cmd" ] && COMPREPLY=($( compgen -W 'all available updates installed
                    extras obsoletes recent' -- "$cur" ));
            return 0
        ;;
        localinstall | localupdate)
            _yum_binrpmfiles "$cur";
            return 0
        ;;
        repolist)
            [ "$prev" = "$cmd" ] && COMPREPLY=($( compgen -W 'all enabled disabled' -- "$cur" ));
            return 0
        ;;
        shell)
            [ "$prev" = "$cmd" ] && COMPREPLY=($( compgen -f -o plusdirs -- "$cur" ));
            return 0
        ;;
        update | upgrade)
            _yum_binrpmfiles "$cur";
            _yum_list updates "$cur";
            return 0
        ;;
        version)
            [ "$prev" = "$cmd" ] && COMPREPLY=($( compgen -W 'all installed available nogroups
                    grouplist groupinfo' -- "$cur" ));
            return 0
        ;;
    esac;
    local split=false;
    declare -F _split_longopt &> /dev/null && _split_longopt && split=true;
    _yum_complete_baseopts "$cur" "$prev" && return 0;
    $split && return 0;
    COMPREPLY=($( compgen -W '$( _yum_baseopts ) ${cmds[@]}' -- "$cur" ))
}
_yum_baseopts () 
{ 
    local opts='--help --tolerant --cacheonly --config --randomwait
        --debuglevel --showduplicates --errorlevel --rpmverbosity --quiet
        --verbose --assumeyes --version --installroot --enablerepo
        --disablerepo --exclude --disableexcludes --obsoletes --noplugins
        --nogpgcheck --skip-broken --color --releasever --setopt';
    [[ $COMP_LINE == *--noplugins* ]] || opts+=" --disableplugin --enableplugin";
    printf %s "$opts"
}
_yum_binrpmfiles () 
{ 
    COMPREPLY+=($( compgen -f -o plusdirs -X '!*.rpm' -- "$1" ));
    COMPREPLY=($( compgen -W '"${COMPREPLY[@]}"' -X '*.src.rpm' ));
    COMPREPLY=($( compgen -W '"${COMPREPLY[@]}"' -X '*.nosrc.rpm' ))
}
_yum_complete_baseopts () 
{ 
    case $2 in 
        -d | --debuglevel | -e | --errorlevel)
            COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9 10' -- "$1" ));
            return 0
        ;;
        --rpmverbosity)
            COMPREPLY=($( compgen -W 'info critical emergency error warn
                debug' -- "$1" ));
            return 0
        ;;
        -c | --config)
            COMPREPLY=($( compgen -f -o plusdirs -X "!*.conf" -- "$1" ));
            return 0
        ;;
        --installroot | --downloaddir)
            COMPREPLY=($( compgen -d -- "$1" ));
            return 0
        ;;
        --enablerepo)
            _yum_repolist disabled "$1";
            return 0
        ;;
        --disablerepo)
            _yum_repolist enabled "$1";
            return 0
        ;;
        --disableexcludes)
            _yum_repolist all "$1";
            COMPREPLY=($( compgen -W '${COMPREPLY[@]} all main' -- "$1" ));
            return 0
        ;;
        --enableplugin)
            _yum_plugins 0 "$1";
            return 0
        ;;
        --disableplugin)
            _yum_plugins 1 "$1";
            return 0
        ;;
        --color)
            COMPREPLY=($( compgen -W 'always auto never' -- "$1" ));
            return 0
        ;;
        -R | --randomwait | -x | --exclude | -h | --help | --version | --releasever | --cve | --bz | --advisory | --tmprepo | --verify-filenames | --setopt)
            return 0
        ;;
        --download-order)
            COMPREPLY=($( compgen -W 'default smallestfirst largestfirst'                 -- "$1" ));
            return 0
        ;;
        --override-protection)
            _yum_list installed "$1";
            return 0
        ;;
        --verify-configuration-files)
            COMPREPLY=($( compgen -W '1 0' -- "$1" ));
            return 0
        ;;
    esac;
    return 1
}
_yum_grouplist () 
{ 
    local IFS='
';
    COMPREPLY=($( compgen -W "$( ${yum:-yum} -C grouplist $1 "$2*"         2>/dev/null | sed -ne 's/^[[:space:]]\{1,\}\(.\{1,\}\)/\1/p' )"         -- "$2" ))
}
_yum_list () 
{ 
    [[ $2 == */* || $2 == [.~]* ]] && return;
    if [ "$1" = all ]; then
        COMPREPLY+=($( ${yum:-yum} -d 0 -C list $1 "$2*" 2>/dev/null |             sed -ne '/^Available /d' -e '/^Installed /d' -e '/^Updated /d'             -e 's/[[:space:]].*//p' ));
    else
        COMPREPLY+=($( ${yum:-yum} -d 0 -C list $1 "$2*" 2>/dev/null |             sed -ne 1d -e 's/[[:space:]].*//p' ));
    fi
}
_yum_plugins () 
{ 
    local val;
    [ $1 = 1 ] && val='\(1\|yes\|true\|on\)' || val='\(0\|no\|false\|off\)';
    COMPREPLY+=($( compgen -W '$( command grep -il "^\s*enabled\s*=\s*$val" \
        /etc/yum/pluginconf.d/*.conf 2>/dev/null \
        | sed -ne "s|^.*/\([^/]\{1,\}\)\.conf$|\1|p" )' -- "$2" ))
}
_yum_repolist () 
{ 
    COMPREPLY+=($( compgen -W "$( ${yum:-yum} --noplugins -C repolist $1 2>/dev/null |             sed -ne '/^repo\s\{1,\}id/d' -e '/^repolist:/d'             -e 's/[[:space:]].*//p' )" -- "$2" ))
}
_yum_transactions () 
{ 
    COMPREPLY+=($( compgen -W "$( $yum -d 0 -C history 2>/dev/null |         sed -ne 's/^[[:space:]]*\([0-9]\{1,\}\).*/\1/p' )" -- "$cur" ))
}
command_not_found_handle () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    else
        if [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1";
            return $?;
        else
            printf "%s: command not found\n" "$1" 1>&2;
            return 127;
        fi;
    fi
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
in_array () 
{ 
    local i;
    for i in "${@:2}";
    do
        [[ $1 = "$i" ]] && return;
    done
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
